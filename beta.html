<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>D2 Armor Analyzer - By ErebusAres</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <link rel="stylesheet" href="beta.css" />

</head>
<body>
  <div class="wrap">
    <header class="panel panel-header">
      <div class="panel-header__layout">
        <div class="panel-header__content">
          <h1>D2 Armor Analyzer</h1>
          <div class="muted">â™¦ Upload your DIM CSV; dupes use topâ€‘3 stat identities within Â± tolerance. Exotics compare only against sameâ€‘name items.</div>
          <div class="muted">â™¦ Click "Restore last" to reload the last uploaded CSV from this browser.</div>
          <div class="muted">â™¦ Click "Copy ID" or A Group Badge to copy to clipboard.</div>
        </div>
        <div class="toolbar">
          <input id="file" type="file" accept=".csv" class="toolbar__input" />
          <label id="uploadTrigger" class="tool-card tool-card--upload" for="file" role="button" tabindex="0">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 4v9" />
                <path d="M9 7l3-3 3 3" />
                <path d="M5 14v6h14v-6" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Upload CSV</span>
              <span class="tool-sub" id="uploadHint" data-default="Choose DIM Armor.csv" aria-live="polite">Choose DIM Armor.csv</span>
            </span>
          </label>
          <button class="tool-card tool-card--restore" id="restoreBtn" type="button" aria-label="Restore last uploaded CSV">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6v6h-6" />
                <path d="M20 12a8 8 0 1 1-8-8" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Restore last</span>
              <span class="tool-sub">Load recent upload</span>
            </span>
          </button>
          <button class="tool-card tool-card--clear" id="clearBtn" type="button" aria-label="Clear all data">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 6h16" />
                <path d="M10 6l1-2h2l1 2" />
                <path d="M7 6l1 14h8l1-14" />
                <path d="M10 11v6" />
                <path d="M14 11v6" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Clear</span>
              <span class="tool-sub">Remove results</span>
            </span>
          </button>
        </div>
      </div>
    </header>

    <section class="panel panel-auth" id="bungiePanel">
      <div class="auth-header">
        <h2>Connect with Bungie</h2>
        <p class="muted">Sign in with your Bungie account to pull armor automatically, or continue using CSV uploads.</p>
      </div>
      <div class="auth-buttons">
        <button id="bungieLogin" type="button" class="btn btn-primary">Sign in with Bungie</button>
        <button id="bungieRefresh" type="button" class="btn">Refresh armor</button>
        <button id="bungieLogout" type="button" class="btn">Sign out</button>
      </div>
      <div id="membershipSelectWrap" class="auth-membership" style="display:none">
        <label class="auth-field">
          <span class="auth-label">Active profile</span>
          <select id="membershipSelect"></select>
        </label>
      </div>
      <div class="auth-note muted">Tokens are stored locally in this browser only.</div>
      <div id="bungieStatus" class="auth-status muted" aria-live="polite"></div>
    </section>

    <section class="panel" style="margin-bottom:16px">
      <div class="filters">
        <div class="line"><span class="label">Class</span><div id="classSeg" class="seg"></div></div>
        <div class="line"><span class="label">Rarity</span><div id="raritySeg" class="seg"></div></div>
        <div class="line"><span class="label">Slot</span><div id="slotSeg" class="seg"></div></div>
        <div class="line"><span class="label">Dupes</span><div id="dupesSeg" class="seg"></div></div>
        <div class="line"><span class="label">Tolerance</span><input id="tol" type="number" min="0" max="20" value="5" style="width:80px"/> <span class="muted">Â± topâ€‘3 stat</span></div>
      </div>
    </section>

    <section class="list">
      <div class="row header">
        <div class="center">Tag</div>
        <div>Item</div>
        <div class="center">Tier</div>
        <div>Base Stats <div class="center-info">(Health, Melee, Grenade, Super, Class, Weapons)</div></div>
        <div class="center">Total</div>
        <div class="center">Group</div>
        <div class="center">Rank</div>
        <div class="right">Copy</div>
      </div>
      <div id="rows"></div>
      <div id="empty" class="empty" style="display:none"><p>
        No items yet â€” upload a DIM CSV or click Restore last.<br/><br/>

        To export from DIM: <br/>
        â™¦ Go to https://app.destinyitemmanager.com/ and sign in. <br/>
        â™¦ Navigate to Organizer. <br/>
        â™¦ Select any class. <br/>
        â™¦ Click the "Armor.csv" button at the top right to download your armor data. <br/>
        â™¦ Upload the downloaded CSV file here. <br/>
      </p></div>
    </section>
  </div>

  <script>
  // ====== Constants ======
  const STAT_COLS = [
    "Health (Base)",
    "Melee (Base)",
    "Grenade (Base)",
    "Super (Base)",
    "Class (Base)",
    "Weapons (Base)"
  ];
  const STAT_ICONS = {
    "Health (Base)":"https://www.bungie.net/common/destiny2_content/icons/717b8b218cc14325a54869bef21d2964.png",
    "Melee (Base)":"https://www.bungie.net/common/destiny2_content/icons/fa534aca76d7f2d7e7b4ba4df4271b42.png",
    "Grenade (Base)":"https://www.bungie.net/common/destiny2_content/icons/065cdaabef560e5808e821cefaeaa22c.png",
    "Super (Base)":"https://www.bungie.net/common/destiny2_content/icons/585ae4ede9c3da96b34086fccccdc8cd.png",
    "Class (Base)":"https://www.bungie.net/common/destiny2_content/icons/7eb845acb5b3a4a9b7e0b2f05f5c43f1.png",
    "Weapons (Base)":"https://www.bungie.net/common/destiny2_content/icons/bc69675acdae9e6b9a68a02fb4d62e07.png"
  };
  const RARITY_ICONS = {
    "Legendary": "https://www.bungie.net/common/destiny2_content/icons/f846f489c2a97afb289b357e431ecf8d.png",
    "Exotic": "https://www.bungie.net/common/destiny2_content/icons/3e6a698e1a8a5fb446fdcbf1e63c5269.png"
  };
  const CLASS_OPTIONS = ["Warlock", "Hunter", "Titan"];
  const SLOT_OPTIONS = ["All", "Helmet", "Gauntlets", "Chest Armor", "Leg Armor", "Class Item"];
  const RARITY_OPTIONS = ["All", "Legendary", "Exotic"];  const DUPES_OPTIONS = ["All", "Only Dupes", "Only Same-Name"];
  const classItemByClass = { Warlock: "Warlock Bond", Hunter: "Hunter Cloak", Titan: "Titan Mark" };
  const TAG_EMOJIS = {
    favorite: "â¤ï¸",
    keep: "ðŸ·ï¸",
    junk: "ðŸš«",
    infuse: "âš¡",
    archive: "ðŸ“¦"
  };
  const TAG_LABELS = {
    favorite: "Favorite",
    keep: "Keep",
    junk: "Junk",
    infuse: "Infuse",
    archive: "Archive"
  };
  const CLASS_ICONS = {
    "Warlock": "https://www.bungie.net/common/destiny2_content/icons/e4006d9a8fe167bd7e83193d7601c89a.png",
    "Hunter":  "https://www.bungie.net/common/destiny2_content/icons/05e32a388d9a65a0ef59b2193eee2db4.png",
    "Titan":   "https://www.bungie.net/common/destiny2_content/icons/46a19ddd00d0f6ca822230943103b54a.png"
  };
  const SLOT_ICONS = {
    "Helmet": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/helmet.svg",
    "Gauntlets": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/gloves.svg",
    "Chest Armor": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/chest.svg",
    "Leg Armor": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/boots.svg",
    "Class Item": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/class.svg"
  };
  const ARMOR_ARCHETYPES = {
    "Grenadier": "https://www.bungie.net/common/destiny2_content/icons/cbf4f03459ab2818a3d37b7362b2aa93.png", // Grenade, Super
    "Paragon": "https://www.bungie.net/common/destiny2_content/icons/b5feb81f684d767d6212ca138f30b34c.png", // Super, Melee
    "Specialist": "https://www.bungie.net/common/destiny2_content/icons/69731c603d7bcdd0a21b26c711d55f03.png", // Class, Weapons
    "Brawler": "https://www.bungie.net/common/destiny2_content/icons/7bc3bc2bccdafc19dde31f867a06ee9f.png", // Melee, Health
    "Bulwark": "https://www.bungie.net/common/destiny2_content/icons/cda905547dd9eac7a39e6e898f619bc5.png", // Health, Class
    "Gunner": "https://www.bungie.net/common/destiny2_content/icons/15e3b3c25a6d4606dcb887cb67c915a1.png" // Weapons, Grenade
  }
  const CLASS_BY_TYPE = { 0: "Titan", 1: "Hunter", 2: "Warlock", 3: "Unknown", 4: "Any" };
  const ARMOR_BUCKET_HASH_TO_TYPE = {
    3448274439: "Helmet",
    3551918588: "Gauntlets",
    14239492: "Chest Armor",
    20886954: "Leg Armor",
    1585787867: "Class Item"
  };
  const STAT_HASH_TO_LABEL = {
    392767087: "Health (Base)",
    4244567218: "Melee (Base)",
    1735777505: "Grenade (Base)",
    144602215: "Super (Base)",
    1943323491: "Class (Base)",
    2996146975: "Weapons (Base)"
  };
  const ARMOR_INTRINSIC_PLUG_CATEGORY_HASHES = new Set([
    1744546145, // PlugCategoryHashes.Intrinsics
    748854354   // PlugCategoryHashes.ArmorStats
  ]);
  const MEMBERSHIP_TYPE_NAMES = {
    1: "Xbox",
    2: "PlayStation",
    3: "Steam",
    4: "Blizzard",
    5: "Stadia",
    6: "Epic",
    7: "Demon",
    10: "Tiger",
    254: "BungieNet"
  };
  const BUNGIE_CONFIG_STORAGE = 'd2aa_bungie_cfg_v1';
  const BUNGIE_TOKEN_STORAGE = 'd2aa_bungie_tokens_v1';
  const BUNGIE_STATE_STORAGE = 'd2aa_bungie_state_v1';
  const BUNGIE_VERIFIER_STORAGE = 'd2aa_bungie_verifier_v1';
  const BUNGIE_RETURN_STORAGE = 'd2aa_bungie_return_v1';
  const BUNGIE_COMPONENTS = '100,102,200,201,205,300,304,305';
  const BUNGIE_OAUTH_URL = 'https://www.bungie.net/en/OAuth/Authorize';
  const BUNGIE_TOKEN_URL = 'https://www.bungie.net/Platform/App/OAuth/Token/';
  const BUNGIE_API_ROOT = 'https://www.bungie.net/Platform';
  const BUNGIE_REDIRECT_URI = (() => {
    try {
      const { origin, pathname } = window.location;
      if (!origin || origin === 'null') {
        return 'https://erebusares.github.io/D2AA/beta.html';
      }
      return `${origin}${pathname}`;
    } catch (err) {
      console.warn('Falling back to default Bungie redirect URI', err);
      return 'https://erebusares.github.io/D2AA/beta.html';
    }
  })();
  const BUNGIE_DEFAULT_API_KEY = '96e154014bdd44c0a537e482709b7473';
  const BUNGIE_DEFAULT_CLIENT_ID = '50794';
  const BUNGIE_ALLOWED_ORIGIN = 'https://erebusares.github.io';
  // ====== Helpers ======
  const normId = (s) => (s ? String(s).trim().replace(/^"|"$/g, "") : "");
  const normName = (s) => String(s || "").trim().toLowerCase();
  const num = (v) => (v == null || v === "" ? 0 : Number(v));
  function slotNumber(type){
    if(type === "Helmet") return 1;
    if(type === "Gauntlets") return 2;
    if(type === "Chest Armor") return 3;
    if(type === "Leg Armor") return 4;
    if(["Warlock Bond","Hunter Cloak","Titan Mark"].includes(type)) return 5;
    return 9;
  }
  function starsLegendary(t){ const n=num(t); if(n>=75) return "â˜…â˜…â˜…â˜…â˜…"; if(n===74) return "â˜…â˜…â˜…â˜…â˜†"; if(n===73) return "â˜…â˜…â˜…â˜†â˜†"; if(n===72) return "â˜…â˜…â˜†â˜†â˜†"; if(n===71) return "â˜…â˜†â˜†â˜†â˜†"; return "ðŸ’©"; }
  function starsExotic(t){ const n=num(t); if(n>=63) return "â˜…â˜…â˜…â˜…â˜…"; if(n===62) return "â˜…â˜…â˜…â˜…â˜†"; if(n===61) return "â˜…â˜…â˜…â˜†â˜†"; if(n===60) return "â˜…â˜…â˜†â˜†â˜†"; if(n===59) return "â˜…â˜†â˜†â˜†â˜†"; return "ðŸ’©"; }
  function statColorCls(v){ if(v>=30) return "stat-cyan"; if(v>=24) return "stat-green"; if(v>=15) return "stat-yellow"; return "stat-red"; }
  function top3Entries(item){
    const arr = STAT_COLS.map(k => ({ name:k, value:num(item[k]) }));
    arr.sort((a,b)=> (b.value - a.value) || a.name.localeCompare(b.name));
    return arr.slice(0,3);
  }
  function similarTop3(a,b,tol){
    const ta = top3Entries(a), tb = top3Entries(b);
    for(let i=0;i<3;i++){
      if(ta[i].name !== tb[i].name) return false;
      if(Math.abs(ta[i].value - tb[i].value) > tol) return false;
    }
    return true;
  }
  function rankScore(rank){ if(!rank) return -1; const stars=(rank.match(/â˜…/g)||[]).length; if(stars>0) return stars; return 0; }
  async function copyTextSafe(text){
    try{
      if(navigator.clipboard && window.isSecureContext){ await navigator.clipboard.writeText(text); return true; }
      throw new Error('clipboard api not available');
    }catch(e){
      try{ const ta=document.createElement('textarea'); ta.value=text; ta.setAttribute('readonly',''); ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select(); const ok=document.execCommand('copy'); document.body.removeChild(ta); return ok; }catch(e2){ alert('Copy failed: '+e2); return false; }
    }
  }

  // ====== State & Storage ======
  let STATE = {
    rows:[],
    classFilter:'Warlock',
    slotFilter:'All',
    rarityFilter:'All',
    tol:5,
    dupesFilter:'All' // NEW
  };
  const LS_KEY = 'd2_armor_rows_v1';
  let bungieConfig = loadBungieConfig();
  let bungieTokens = loadBungieTokens();
  let bungieMemberships = [];
  let bungieIsFetching = false;
  let bungieAutoLoadedOnce = false;
  const manifestCache = {
    inventoryItem: new Map(),
    bucket: new Map()
  };
  let bungieStatusEl = null;
  let bungieMembershipSelect = null;
  let bungieMembershipWrap = null;
  let bungieLoginBtn = null;
  let bungieRefreshBtn = null;
  let bungieLogoutBtn = null;
  function saveRows(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(STATE.rows)); }catch(_){} }
  function loadRows(){ try{ const s=localStorage.getItem(LS_KEY); if(!s) return null; return JSON.parse(s); }catch(_){ return null; } }

  // ====== Filters UI ======
  function makeSeg(containerId, options, key){
  const el = document.getElementById(containerId); if(!el) return; el.innerHTML='';
  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'chip' + (STATE[key]===opt ? ' active' : '');
    let label = opt;
    // Add icons for class, rarity, and slot filters
    if (containerId === 'classSeg' && CLASS_ICONS[opt]) {
      label = `<span class="chip-icon-mask" style="mask-image:url('${CLASS_ICONS[opt]}');-webkit-mask-image:url('${CLASS_ICONS[opt]}');"></span>${opt}`;
    }
    if (containerId === 'raritySeg' && RARITY_ICONS[opt]) {
      label = `<img src="${RARITY_ICONS[opt]}" alt="${opt}" title="${opt}" class="chip-icon rarity" style="height:1em;vertical-align:middle;margin-right:4px;">${opt}`;
    }
    if (containerId === 'slotSeg' && SLOT_ICONS[opt]) {
      label = `<span class="chip-icon-mask" style="mask-image:url('${SLOT_ICONS[opt]}');-webkit-mask-image:url('${SLOT_ICONS[opt]}');"></span>${opt}`;
    }
    btn.innerHTML = (STATE[key]===opt? 'â— ' : 'â—‹ ') + label;
    btn.addEventListener('click', ()=>{ STATE[key]=opt; render(); makeSeg(containerId, options, key); });
    el.appendChild(btn);
  });
}
  function initFilters(){
    makeSeg('classSeg', CLASS_OPTIONS, 'classFilter');
    makeSeg('raritySeg', RARITY_OPTIONS, 'rarityFilter');
    makeSeg('slotSeg',   SLOT_OPTIONS,   'slotFilter');
    makeSeg('dupesSeg',  DUPES_OPTIONS,  'dupesFilter'); // NEW
  }

  // ====== Data selection ======
  function getFiltered(){
  const expected = classItemByClass[STATE.classFilter];
  // Always group on the full set for dupe logic
  let baseFiltered = STATE.rows.filter(r =>
    (STATE.classFilter ? r.Equippable === STATE.classFilter : true) &&
    (STATE.slotFilter==='All' ? true : STATE.slotFilter==='Class Item' ? r.Type===expected : r.Type===STATE.slotFilter) &&
    (STATE.rarityFilter==='All' ? true : r.Rarity === STATE.rarityFilter)
  );
  // Get all grouped rows for this filtered set
  const grouped = clusterRows(baseFiltered);

  if (STATE.dupesFilter === "Only Dupes") {
    // Show only items in any dupe group (Dupe_Group !== "X")
    return grouped.filter(r => r.Dupe_Group && r.Dupe_Group !== "X");
  } else if (STATE.dupesFilter === "Only Same-Name") {
    // Show only dupe groups where all items share the same name
    // 1. Find all dupe groups
    const dupeGroups = {};
    for (const r of grouped) {
      if (r.Dupe_Group && r.Dupe_Group !== "X") {
        const key = `${r.GroupKey}::${r.Dupe_Group}`;
        if (!dupeGroups[key]) dupeGroups[key] = [];
        dupeGroups[key].push(r);
      }
    }
    // 2. Keep only groups where all items have the same normalized name
    const validIds = new Set();
    for (const group of Object.values(dupeGroups)) {
      const names = new Set(group.map(r => normName(r.Name)));
      if (names.size === 1) {
        for (const r of group) validIds.add(r.Id);
      }
    }
    return grouped.filter(r => validIds.has(r.Id));
  }
  // Default: show all
  return grouped;
}

  // ====== Bungie API Integration ======
  function getDefaultTokenState(){
    return {
      accessToken:null,
      refreshToken:null,
      accessTokenExpires:0,
      refreshTokenExpires:0,
      tokenType:'Bearer',
      membershipId:null,
      membershipType:null
    };
  }

  function loadBungieConfig(){
    const defaults = {
      apiKey: BUNGIE_DEFAULT_API_KEY,
      clientId: BUNGIE_DEFAULT_CLIENT_ID,
      membershipId: null,
      membershipType: null
    };
    try{
      const raw = localStorage.getItem(BUNGIE_CONFIG_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return {
        apiKey: BUNGIE_DEFAULT_API_KEY,
        clientId: BUNGIE_DEFAULT_CLIENT_ID,
        membershipId: parsed?.membershipId ?? null,
        membershipType: parsed?.membershipType ?? null
      };
    }catch(err){
      console.warn('Failed to parse Bungie config', err);
      return { ...defaults };
    }
  }

  function saveBungieConfig(){
    try{
      const payload = {
        membershipId: bungieConfig?.membershipId ?? null,
        membershipType: bungieConfig?.membershipType ?? null
      };
      localStorage.setItem(BUNGIE_CONFIG_STORAGE, JSON.stringify(payload));
    }catch(err){
      console.warn('Failed to persist Bungie config', err);
    }
  }

  function ensureBungieConfigDefaults(){
    if(!bungieConfig) bungieConfig = loadBungieConfig();
    bungieConfig.apiKey = BUNGIE_DEFAULT_API_KEY;
    bungieConfig.clientId = BUNGIE_DEFAULT_CLIENT_ID;
    if(bungieConfig.membershipId == null) bungieConfig.membershipId = null;
    if(bungieConfig.membershipType == null) bungieConfig.membershipType = null;
  }

  function loadBungieTokens(){
    const defaults = getDefaultTokenState();
    try{
      const raw = localStorage.getItem(BUNGIE_TOKEN_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return { ...defaults, ...parsed };
    }catch(err){
      console.warn('Failed to load Bungie tokens', err);
      return { ...defaults };
    }
  }

  function saveBungieTokens(){
    try{
      if(!bungieTokens || (!bungieTokens.accessToken && !bungieTokens.refreshToken)){
        localStorage.removeItem(BUNGIE_TOKEN_STORAGE);
        return;
      }
      localStorage.setItem(BUNGIE_TOKEN_STORAGE, JSON.stringify(bungieTokens));
    }catch(err){
      console.warn('Failed to persist Bungie tokens', err);
    }
  }

  function clearBungieTokens(showMessage){
    bungieTokens = getDefaultTokenState();
    bungieMemberships = [];
    bungieAutoLoadedOnce = false;
    localStorage.removeItem(BUNGIE_TOKEN_STORAGE);
    renderMembershipOptions();
    updateBungieUI();
    if(showMessage){
      setBungieStatus('Signed out. You can still upload CSV files manually.', 'info');
    }
  }

  function updateBungieUI(){
    const hasConfig = Boolean((bungieConfig?.apiKey || '').trim() && (bungieConfig?.clientId || '').trim());
    const hasRefresh = Boolean(bungieTokens?.refreshToken);
    const refreshValid = hasRefresh && Date.now() < ((bungieTokens.refreshTokenExpires || 0) - 60000);
    const signedIn = hasRefresh && refreshValid;
    if(bungieLoginBtn) bungieLoginBtn.disabled = bungieIsFetching || !hasConfig;
    if(bungieRefreshBtn) bungieRefreshBtn.disabled = bungieIsFetching || !signedIn || !hasConfig;
    if(bungieLogoutBtn) bungieLogoutBtn.disabled = bungieIsFetching || !hasRefresh;
    if(bungieMembershipWrap){
      bungieMembershipWrap.style.display = bungieMemberships.length ? 'block' : 'none';
    }
  }

  function renderMembershipOptions(){
    if(!bungieMembershipSelect || !bungieMembershipWrap){
      return;
    }
    bungieMembershipSelect.innerHTML = '';
    if(!bungieMemberships.length){
      bungieMembershipWrap.style.display = 'none';
      return;
    }
    bungieMembershipWrap.style.display = 'block';
    let hasSelection = false;
    for(const mem of bungieMemberships){
      const opt = document.createElement('option');
      opt.value = `${mem.membershipType}:${mem.membershipId}`;
      opt.textContent = mem.label;
      if(String(bungieConfig?.membershipType) === String(mem.membershipType) && String(bungieConfig?.membershipId) === String(mem.membershipId)){
        opt.selected = true;
        hasSelection = true;
      }
      bungieMembershipSelect.appendChild(opt);
    }
    if(!hasSelection && bungieMembershipSelect.options.length > 0){
      bungieMembershipSelect.selectedIndex = 0;
      const [type,id] = bungieMembershipSelect.value.split(':');
      bungieConfig.membershipType = Number(type);
      bungieConfig.membershipId = id;
      saveBungieConfig();
    }
    updateBungieUI();
  }

  function formatMembershipLabel(mem){
    const code = mem?.bungieGlobalDisplayNameCode != null ? String(mem.bungieGlobalDisplayNameCode).padStart(4,'0') : '';
    const baseName = mem?.bungieGlobalDisplayName ? `${mem.bungieGlobalDisplayName}${code ? '#' + code : ''}` : (mem?.displayName || mem?.lastSeenDisplayName || 'Guardian');
    const platform = MEMBERSHIP_TYPE_NAMES[mem?.membershipType] || `Type ${mem?.membershipType}`;
    return `${baseName} â€¢ ${platform}`;
  }

  function getSelectedMembership(){
    if(!bungieMemberships.length) return null;
    const found = bungieMemberships.find(mem => String(mem.membershipType) === String(bungieConfig?.membershipType) && String(mem.membershipId) === String(bungieConfig?.membershipId));
    if(found) return found;
    const fallback = bungieMemberships[0];
    if(fallback){
      bungieConfig.membershipType = fallback.membershipType;
      bungieConfig.membershipId = fallback.membershipId;
      saveBungieConfig();
      renderMembershipOptions();
    }
    return fallback || null;
  }

  function setBungieStatus(message, type='info'){
    if(!bungieStatusEl) return;
    bungieStatusEl.textContent = message || '';
    bungieStatusEl.classList.remove('status-ok','status-error','status-loading');
    const isInfo = !message || type === 'info';
    bungieStatusEl.classList.toggle('muted', isInfo);
    if(type === 'ok') bungieStatusEl.classList.add('status-ok');
    else if(type === 'error') bungieStatusEl.classList.add('status-error');
    else if(type === 'loading') bungieStatusEl.classList.add('status-loading');
  }

  const PKCE_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';

  function randomString(length){
    const array = new Uint8Array(length);
    if(window.crypto?.getRandomValues){
      window.crypto.getRandomValues(array);
    }else{
      for(let i=0;i<length;i++){ array[i] = Math.floor(Math.random()*PKCE_CHARSET.length); }
    }
    let out = '';
    for(let i=0;i<length;i++){
      out += PKCE_CHARSET[array[i] % PKCE_CHARSET.length];
    }
    return out;
  }

  function base64UrlEncode(buffer){
    let binary = '';
    const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    for(let i=0;i<bytes.byteLength;i++){
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }

  async function createCodeChallenge(verifier){
    if(!window.crypto?.subtle){
      throw new Error('Browser crypto API is not available for PKCE.');
    }
    const data = new TextEncoder().encode(verifier);
    const digest = await window.crypto.subtle.digest('SHA-256', data);
    return base64UrlEncode(new Uint8Array(digest));
  }

  async function startBungieAuth(){
    try{
      ensureBungieConfigDefaults();
      if(!bungieConfig?.clientId || !bungieConfig?.apiKey){
        setBungieStatus('Bungie credentials are missing. Refresh and try again.', 'error');
        return;
      }
      saveBungieConfig();
      const verifier = randomString(64);
      const challenge = await createCodeChallenge(verifier);
      const state = randomString(32);
      const returnUrl = window.location.href.split('#')[0];
      const redirectUri = BUNGIE_REDIRECT_URI || returnUrl;
      sessionStorage.setItem(BUNGIE_VERIFIER_STORAGE, verifier);
      sessionStorage.setItem(BUNGIE_STATE_STORAGE, state);
      sessionStorage.setItem(BUNGIE_RETURN_STORAGE, returnUrl);
      const url = new URL(BUNGIE_OAUTH_URL);
      url.searchParams.set('client_id', bungieConfig.clientId);
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('state', state);
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('code_challenge_method', 'S256');
      if(redirectUri){
        url.searchParams.set('redirect_uri', redirectUri);
      }
      setBungieStatus('Redirecting to Bungie for sign-inâ€¦', 'loading');
      window.location.href = url.toString();
    }catch(err){
      console.error(err);
      setBungieStatus('Unable to start Bungie sign-in: ' + (err?.message || err), 'error');
    }
  }

  function cleanOAuthParams(){
    const storedReturn = sessionStorage.getItem(BUNGIE_RETURN_STORAGE);
    if(storedReturn){
      window.history.replaceState({}, document.title, storedReturn);
      return;
    }
    try{
      const current = new URL(window.location.href);
      current.searchParams.delete('code');
      current.searchParams.delete('state');
      current.searchParams.delete('error');
      current.searchParams.delete('error_description');
      window.history.replaceState({}, document.title, current.toString());
    }catch(err){
      console.warn('Failed to clean OAuth params', err);
    }
  }

  async function handleOAuthRedirect(){
    const params = new URLSearchParams(window.location.search);
    const error = params.get('error');
    if(error){
      cleanOAuthParams();
      setBungieStatus(`Authorization failed: ${error}`, 'error');
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
      return;
    }
    const code = params.get('code');
    if(!code) return;
    const state = params.get('state');
    const storedState = sessionStorage.getItem(BUNGIE_STATE_STORAGE);
    const verifier = sessionStorage.getItem(BUNGIE_VERIFIER_STORAGE);
    if(!storedState || !verifier || storedState !== state){
      cleanOAuthParams();
      setBungieStatus('Authorization state mismatch. Please try signing in again.', 'error');
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
      return;
    }
    try{
      setBungieStatus('Completing Bungie authorizationâ€¦', 'loading');
      const redirectUri = sessionStorage.getItem(BUNGIE_RETURN_STORAGE) || BUNGIE_REDIRECT_URI;
      const loaded = await exchangeAuthCode(code, verifier, redirectUri);
      if(!loaded){
        const hasError = bungieStatusEl?.classList?.contains('status-error');
        if(!hasError){
          setBungieStatus('Authorization complete. Use Refresh armor to pull your gear.', 'ok');
        }
      }
    }catch(err){
      console.error(err);
      setBungieStatus('Failed to complete authorization: ' + (err?.message || err), 'error');
    }finally{
      cleanOAuthParams();
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
    }
  }

  async function exchangeAuthCode(code, verifier, redirectUri){
    ensureBungieConfigDefaults();
    const body = new URLSearchParams();
    body.set('client_id', bungieConfig?.clientId || '');
    body.set('grant_type', 'authorization_code');
    body.set('code', code);
    body.set('code_verifier', verifier);
    if(redirectUri){
      body.set('redirect_uri', redirectUri);
    }
    const headers = new Headers({
      'Content-Type':'application/x-www-form-urlencoded',
      'Accept':'application/json'
    });
    let resp;
    try{
      resp = await fetch(BUNGIE_TOKEN_URL, {
        method:'POST',
        headers,
        body
      });
    }catch(err){
      throw new Error(formatBungieNetworkError(err));
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok){
      const rawMsg = data?.error_description || data?.Message || `HTTP ${resp.status}`;
      const msg = rawMsg === 'OriginHeaderDoesNotMatchKey'
        ? 'OriginHeaderDoesNotMatchKey: Add https://erebusares.github.io to the Origin Header whitelist for your Bungie application and redeploy.'
        : rawMsg;
      throw new Error(msg);
    }
    if(!data?.access_token){
      throw new Error('Missing access token in Bungie response.');
    }
    bungieTokens = {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      accessTokenExpires: Date.now() + (Number(data.expires_in || 0) * 1000),
      refreshTokenExpires: Date.now() + (Number(data.refresh_expires_in || 0) * 1000),
      tokenType: data.token_type || 'Bearer',
      membershipId: data.membership_id || bungieConfig?.membershipId || null,
      membershipType: data.membership_type != null ? data.membership_type : bungieConfig?.membershipType || null
    };
    saveBungieTokens();
    updateBungieUI();
    const membership = await fetchMemberships();
    if(membership){
      const loaded = await loadArmorFromBungie({ reason: 'auto' });
      return loaded;
    }
    return false;
  }

  async function ensureAccessToken(){
    const hasAccess = Boolean(bungieTokens?.accessToken);
    const hasRefresh = Boolean(bungieTokens?.refreshToken);
    const now = Date.now();
    const accessExpires = Number(bungieTokens?.accessTokenExpires || 0);
    const refreshExpires = Number(bungieTokens?.refreshTokenExpires || 0);

    // If we have a usable access token, return it even if no refresh token exists yet.
    if(hasAccess && (!accessExpires || now < (accessExpires - 60000))){
      return bungieTokens.accessToken;
    }

    if(!hasRefresh){
      throw new Error('No Bungie session available. Sign in first.');
    }

    if(refreshExpires && now >= (refreshExpires - 60000)){
      clearBungieTokens(false);
      throw new Error('Bungie session expired. Please sign in again.');
    }

    await refreshAccessToken();
    return bungieTokens.accessToken;
  }

  async function refreshAccessToken(){
    ensureBungieConfigDefaults();
    const body = new URLSearchParams();
    body.set('client_id', bungieConfig?.clientId || '');
    body.set('grant_type', 'refresh_token');
    body.set('refresh_token', bungieTokens?.refreshToken || '');
    const headers = new Headers({
      'Content-Type':'application/x-www-form-urlencoded',
      'Accept':'application/json'
    });
    let resp;
    try{
      resp = await fetch(BUNGIE_TOKEN_URL, {
        method:'POST',
        headers,
        body
      });
    }catch(err){
      throw new Error(formatBungieNetworkError(err));
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok || !data?.access_token){
      const rawMsg = data?.error_description || data?.Message || `HTTP ${resp.status}`;
      const msg = rawMsg === 'OriginHeaderDoesNotMatchKey'
        ? 'OriginHeaderDoesNotMatchKey: Add https://erebusares.github.io to the Origin Header whitelist for your Bungie application and redeploy.'
        : rawMsg;
      clearBungieTokens(false);
      throw new Error(msg);
    }
    bungieTokens.accessToken = data.access_token;
    bungieTokens.accessTokenExpires = Date.now() + (Number(data.expires_in || 0) * 1000);
    if(data.refresh_token){
      bungieTokens.refreshToken = data.refresh_token;
    }
    if(data.refresh_expires_in){
      bungieTokens.refreshTokenExpires = Date.now() + Number(data.refresh_expires_in) * 1000;
    }
    if(data.token_type){
      bungieTokens.tokenType = data.token_type;
    }
    if(data.membership_id){
      bungieTokens.membershipId = data.membership_id;
    }
    if(data.membership_type != null){
      bungieTokens.membershipType = data.membership_type;
    }
    saveBungieTokens();
  }

  function formatBungieNetworkError(err){
    const rawMessage = (err?.message || '').trim();
    const normalized = rawMessage || 'Network request failed.';
    const lowered = normalized.toLowerCase();
    if(lowered.includes('failed to fetch') || lowered.includes('networkerror') || lowered.includes('load failed')){
      let currentOrigin = '';
      try{
        currentOrigin = window.location?.origin || '';
      }catch(_){
        currentOrigin = '';
      }
      const isOpaque = !currentOrigin || currentOrigin === 'null';
      if(isOpaque){
        return `Network error contacting Bungie. Serve this page from ${BUNGIE_ALLOWED_ORIGIN} or another web server and add that origin to your Bungie application's Origin Header whitelist before trying again.`;
      }
      if(currentOrigin !== BUNGIE_ALLOWED_ORIGIN){
        return `Network error contacting Bungie from ${currentOrigin}. Add this origin (without a trailing slash) to the Bungie application's Origin Header whitelist alongside ${BUNGIE_ALLOWED_ORIGIN}, publish the change, and reload before trying again.`;
      }
      return `Network error contacting Bungie from ${currentOrigin}. Confirm this origin appears in the Bungie application's Origin Header whitelist and try again in a few moments.`;
    }
    return normalized;
  }

  function formatBungieError(data, status){
    const rawMessage = data?.Message || data?.message || data?.error_description || data?.error || `HTTP ${status}`;
    const errorStatus = data?.ErrorStatus || data?.Error || data?.error;
    const normalized = (rawMessage || '').trim();
    const originMismatch = normalized === 'Origin header does not match the provided API key.'
      || normalized === 'OriginHeaderDoesNotMatchKey'
      || errorStatus === 'OriginHeaderDoesNotMatchKey';
    if(originMismatch){
      let currentOrigin = '';
      try{
        currentOrigin = window.location?.origin || '';
      }catch(_){
        currentOrigin = '';
      }
      const isOpaqueOrigin = !currentOrigin || currentOrigin === 'null';
      if(isOpaqueOrigin){
        return `OriginHeaderDoesNotMatchKey: Bungie rejected the request because local files do not set an Origin header. Serve this page from ${BUNGIE_ALLOWED_ORIGIN} or run it through a local web server (for example, http://localhost:4173) and add that origin to the Bungie application's Origin Header whitelist before retrying.`;
      }
      if(currentOrigin !== BUNGIE_ALLOWED_ORIGIN){
        return `OriginHeaderDoesNotMatchKey: Bungie rejected the request because ${currentOrigin} is not on the API key's Origin Header whitelist. Add both ${currentOrigin} and ${BUNGIE_ALLOWED_ORIGIN} (no trailing slashes) in the Bungie developer portal, publish the change, and reload.`;
      }
      return `OriginHeaderDoesNotMatchKey: Bungie rejected the request even though the page is hosted on ${BUNGIE_ALLOWED_ORIGIN}. Double-check the application's Origin Header whitelist in the Bungie developer portal, publish the update, wait a few minutes for it to propagate, and reload before trying again.`;
    }
    return normalized || `HTTP ${status}`;
  }

  async function bungieApiRequest(path, options={}, retry=true){
    ensureBungieConfigDefaults();
    const cfg = bungieConfig || {};
    if(!cfg.apiKey){
      throw new Error('Bungie API key is missing.');
    }
    await ensureAccessToken();
    const headers = new Headers(options.headers || {});
    headers.set('X-API-Key', cfg.apiKey);
    headers.set('Authorization', `${bungieTokens?.tokenType || 'Bearer'} ${bungieTokens?.accessToken || ''}`);
    headers.set('Accept', 'application/json');
    let resp;
    try{
      resp = await fetch(`${BUNGIE_API_ROOT}${path}`, {
        method: options.method || 'GET',
        ...options,
        headers
      });
    }catch(err){
      throw new Error(formatBungieNetworkError(err));
    }
    if(resp.status === 401 && retry){
      await refreshAccessToken();
      return bungieApiRequest(path, options, false);
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok){
      throw new Error(formatBungieError(data, resp.status));
    }
    if(data?.ErrorCode && data.ErrorCode !== 1){
      throw new Error(formatBungieError(data, resp.status));
    }
    return data?.Response;
  }

  function hashKey(hash){
    const num = Number(hash);
    if(Number.isNaN(num)) return String(hash);
    return String(num >>> 0);
  }

  async function getInventoryItemDefinition(hash){
    const key = hashKey(hash);
    if(manifestCache.inventoryItem.has(key)){
      return manifestCache.inventoryItem.get(key);
    }
    const def = await bungieApiRequest(`/Destiny2/Manifest/DestinyInventoryItemDefinition/${key}/`);
    manifestCache.inventoryItem.set(key, def);
    return def;
  }

  async function prefetchInventoryItemDefinitions(hashes, concurrency = 10){
    if(!Array.isArray(hashes) || hashes.length === 0){
      return;
    }
    const queue = [];
    const seen = new Set();
    for(const rawHash of hashes){
      const key = hashKey(rawHash);
      if(!key || seen.has(key)){
        continue;
      }
      seen.add(key);
      if(manifestCache.inventoryItem.has(key)){
        continue;
      }
      queue.push(key);
    }
    while(queue.length){
      const batch = queue.splice(0, Math.max(1, concurrency));
      await Promise.all(batch.map(async hash => {
        try{
          await getInventoryItemDefinition(hash);
        }catch(err){
          console.error('Failed to preload manifest definition', hash, err);
          throw err;
        }
      }));
    }
  }

  async function transformProfileToRows(profile){
    const itemsMap = new Map();
    const addItems = (items)=>{
      if(!Array.isArray(items)) return;
      for(const item of items){
        if(!item || !item.itemInstanceId) continue;
        if(itemsMap.has(item.itemInstanceId)) continue;
        itemsMap.set(item.itemInstanceId, item);
      }
    };
    addItems(profile?.profileInventory?.data?.items);
    const charInventories = profile?.characterInventories?.data || {};
    for(const inv of Object.values(charInventories)){
      addItems(inv?.items);
    }
    const charEquipment = profile?.characterEquipment?.data || {};
    for(const equip of Object.values(charEquipment)){
      addItems(equip?.items);
    }
    if(itemsMap.size === 0) return [];
    const instances = profile?.itemComponents?.instances?.data || {};
    const statsByItem = profile?.itemComponents?.stats?.data || {};
    const socketsByItem = profile?.itemComponents?.sockets?.data || {};
    const relevantItems = [];
    for(const [instanceId, item] of itemsMap.entries()){
      const bucketKey = hashKey(item.bucketHash);
      let isArmorCandidate = !!ARMOR_BUCKET_HASH_TO_TYPE[bucketKey];
      if(!isArmorCandidate){
        const statMap = statsByItem?.[instanceId]?.stats;
        if(statMap){
          for(const statHash of Object.keys(statMap)){
            if(STAT_HASH_TO_LABEL[hashKey(statHash)]){
              isArmorCandidate = true;
              break;
            }
          }
        }
      }
      if(!isArmorCandidate){
        const energy = instances?.[instanceId]?.energy;
        if(energy && (Number.isFinite(energy?.energyCapacity) || Number.isFinite(energy?.energyLevel))){
          isArmorCandidate = true;
        }
      }
      if(isArmorCandidate){
        relevantItems.push(item);
      }
    }
    if(relevantItems.length === 0) return [];
    const uniqueItemKeys = new Set();
    const uniqueItemHashes = [];
    const plugKeys = new Set();
    const plugHashList = [];
    for(const item of relevantItems){
      const itemKey = hashKey(item.itemHash);
      if(itemKey && !uniqueItemKeys.has(itemKey)){
        uniqueItemKeys.add(itemKey);
        uniqueItemHashes.push(item.itemHash);
      }
      const sockets = socketsByItem?.[item.itemInstanceId]?.sockets;
      if(!Array.isArray(sockets)) continue;
      for(const socket of sockets){
        if(!socket || socket.isEnabled === false || socket?.plugged?.enabled === false) continue;
        const plugHash = getSocketPlugHash(socket);
        const plugKey = plugHash != null ? hashKey(plugHash) : null;
        if(!plugKey || plugKeys.has(plugKey)) continue;
        plugKeys.add(plugKey);
        plugHashList.push(plugHash);
      }
    }
    await prefetchInventoryItemDefinitions(uniqueItemHashes.concat(plugHashList));
    const rows = [];
    for(const item of relevantItems){
      const def = await getInventoryItemDefinition(item.itemHash);
      const sockets = socketsByItem?.[item.itemInstanceId]?.sockets || [];
      const row = buildRowFromDefinition(
        item,
        def,
        instances[item.itemInstanceId],
        statsByItem[item.itemInstanceId]?.stats || {},
        sockets
      );
      if(row) rows.push(row);
    }
    return rows;
  }

  function getSocketPlugHash(socket){
    if(!socket) return null;
    const plugHash = socket?.plugged?.plugItemHash
      ?? socket?.plugged?.plugHash
      ?? socket?.plugHash
      ?? socket?.plugItemHash;
    return plugHash != null ? plugHash : null;
  }

  // Destiny Item Manager derives armor base stats by removing every socket-provided
  // stat bonus except for intrinsic/frame plugs. We mirror that approach here so the
  // Bungie sourced rows line up with the CSV export that players are used to comparing.
  function shouldSubtractPlugFromBaseStats(def, plugStats){
    if(!plugStats || plugStats.size === 0) return false;
    if(!def) return true;
    const plugCategoryHash = Number(def?.plug?.plugCategoryHash);
    if(Number.isFinite(plugCategoryHash) && ARMOR_INTRINSIC_PLUG_CATEGORY_HASHES.has(plugCategoryHash)){
      return false;
    }
    const plugCat = String(def?.plug?.plugCategoryIdentifier || '').toLowerCase();
    if(plugCat){
      if(plugCat === 'intrinsics' || plugCat.startsWith('intrinsics.')) return false;
      if(plugCat.startsWith('frames')) return false;
      if(plugCat.includes('armorstat')) return false;
      if(plugCat.includes('armor_stats')) return false;
      if(plugCat.includes('tracker')) return false;
      if(plugCat.includes('ornament')) return false;
      if(plugCat.includes('cosmetic')) return false;
      if(plugCat.includes('spawnfx')) return false;
    }
    const typeName = String(def?.itemTypeDisplayName || '').toLowerCase();
    if(typeName.includes('ornament') || typeName.includes('shader') || typeName.includes('projection')) return false;
    const displayName = String(def?.displayProperties?.name || '').toLowerCase();
    if(displayName.includes('ornament') || displayName.includes('shader')) return false;
    return true;
  }

  function isMasterworkStatPlug(def){
    if(!def) return false;
    const plugCat = String(def?.plug?.plugCategoryIdentifier || '').toLowerCase();
    if(plugCat && plugCat.includes('masterwork')) return true;
    const typeName = String(def?.itemTypeDisplayName || '').toLowerCase();
    if(typeName.includes('masterwork')) return true;
    const displayName = String(def?.displayProperties?.name || '').toLowerCase();
    if(displayName.includes('masterwork')) return true;
    return false;
  }

  function getPlugStatValues(socket, plugDef){
    const values = new Map();
    const plugStats = socket?.plugged?.stats;
    if(plugStats && typeof plugStats === 'object'){
      for(const [hash, entry] of Object.entries(plugStats)){
        const statKey = hashKey(hash);
        const label = STAT_HASH_TO_LABEL[statKey];
        if(!label) continue;
        const raw = typeof entry === 'object' && entry !== null ? entry.value : entry;
        const numeric = Number(raw ?? 0);
        if(!Number.isFinite(numeric) || numeric === 0) continue;
        values.set(label, (values.get(label) || 0) + numeric);
      }
    }
    if(values.size === 0 && plugDef){
      const invStats = Array.isArray(plugDef?.investmentStats) ? plugDef.investmentStats : [];
      for(const stat of invStats){
        const statKey = hashKey(stat?.statTypeHash);
        const label = STAT_HASH_TO_LABEL[statKey];
        const value = Number(stat?.value ?? 0);
        if(!label || !Number.isFinite(value) || value === 0) continue;
        values.set(label, (values.get(label) || 0) + value);
      }
    }
    return values;
  }

  function getStatAdjustmentsFromSockets(sockets){
    const adjustments = {};
    const masterworkAdjustments = {};
    if(!Array.isArray(sockets)) return { adjustments, masterworkAdjustments };
    for(const socket of sockets){
      if(!socket || socket.isEnabled === false || socket?.plugged?.enabled === false) continue;
      const plugHash = getSocketPlugHash(socket);
      if(plugHash == null) continue;
      const plugDef = manifestCache.inventoryItem.get(hashKey(plugHash));
      const plugStats = getPlugStatValues(socket, plugDef);
      if(!shouldSubtractPlugFromBaseStats(plugDef, plugStats)) continue;
      const isMasterwork = isMasterworkStatPlug(plugDef);
      for(const [label, value] of plugStats.entries()){
        adjustments[label] = (adjustments[label] || 0) + value;
        if(isMasterwork){
          masterworkAdjustments[label] = (masterworkAdjustments[label] || 0) + value;
        }
      }
    }
    return { adjustments, masterworkAdjustments };
  }

  function buildRowFromDefinition(item, def, instance, stats, sockets){
    if(!def || !def.inventory) return null;
    if(def.itemType !== 2) return null;
    if(def.classType != null && def.classType > 2 && def.classType !== 3 && def.classType !== 4) return null;
    const bucketKey = hashKey(def.inventory.bucketTypeHash);
    if(!ARMOR_BUCKET_HASH_TO_TYPE[bucketKey]) return null;
    const className = CLASS_BY_TYPE[def.classType] || 'Any';
    const isClassItem = bucketKey === String(1585787867);
    const typeName = isClassItem
      ? (classItemByClass[className] || def.itemTypeDisplayName || 'Class Item')
      : (def.itemTypeDisplayName || ARMOR_BUCKET_HASH_TO_TYPE[bucketKey] || 'Armor');
    const tierValue = instance?.energy?.energyCapacity ?? instance?.energy?.energyLevel ?? 0;
    const row = {
      Id: normId(item.itemInstanceId || item.itemHash),
      Name: def?.displayProperties?.name || 'Unknown Item',
      Type: typeName,
      Equippable: className === 'Unknown' ? 'Any' : className,
      Rarity: def?.inventory?.tierTypeName || '',
      Tag: '',
      Power: instance?.primaryStat?.value ?? '',
      Tier: Number.isFinite(tierValue) ? tierValue : 0,
      'Total (Base)': 0
    };
    let socketDetails = null;
    const isMasterworked = Number(instance?.energy?.energyCapacity) === 10;
    for(const [hash,label] of Object.entries(STAT_HASH_TO_LABEL)){
      const stat = stats?.[hash];
      const value = Number(stat?.value ?? 0);
      const numericValue = Number.isFinite(value) ? value : 0;
      if(socketDetails === null){
        socketDetails = getStatAdjustmentsFromSockets(sockets);
      }
      const adjustment = Number(socketDetails?.adjustments?.[label] ?? 0);
      const baseFromSockets = Number.isFinite(adjustment)
        ? Math.max(0, numericValue - adjustment)
        : numericValue;
      const baseFromStat = Number(stat?.base);
      const hasUsefulBaseStat = Number.isFinite(baseFromStat) && baseFromStat > 0;
      let baseValue;
      if(hasUsefulBaseStat){
        baseValue = Number.isFinite(adjustment) && adjustment !== 0
          ? Math.min(baseFromStat, baseFromSockets)
          : baseFromStat;
      }else{
        baseValue = baseFromSockets;
      }
      if(!Number.isFinite(baseValue)){
        baseValue = 0;
      }
      const masterworkContribution = Number(socketDetails?.masterworkAdjustments?.[label] ?? 0);
      if(isMasterworked && masterworkContribution < 2){
        baseValue = Math.max(0, baseValue - 2);
      }
      row[label] = baseValue;
      row['Total (Base)'] += baseValue;
    }
    row['Total (Base)'] = Number.isFinite(row['Total (Base)']) ? row['Total (Base)'] : 0;
    return row;
  }

  async function fetchMemberships(){
    try{
      const resp = await bungieApiRequest('/User/GetMembershipsForCurrentUser/');
      const memberships = Array.isArray(resp?.destinyMemberships) ? resp.destinyMemberships : [];
      bungieMemberships = memberships.map(m => ({
        membershipId: m.membershipId,
        membershipType: m.membershipType,
        label: formatMembershipLabel(m)
      }));
      let selected = null;
      if(!bungieMemberships.length){
        setBungieStatus('No Destiny 2 memberships were found for this account.', 'error');
      }else{
        selected = bungieMemberships.find(mem => String(mem.membershipType) === String(bungieConfig?.membershipType) && String(mem.membershipId) === String(bungieConfig?.membershipId)) || null;
        if(!selected){
          selected = bungieMemberships[0];
          bungieConfig.membershipType = selected.membershipType;
          bungieConfig.membershipId = selected.membershipId;
          saveBungieConfig();
        }
        if(selected){
          setBungieStatus(`Signed in as ${selected.label}.`, 'ok');
        }else{
          setBungieStatus('Signed in, but no profile is selected.', 'error');
        }
      }
      renderMembershipOptions();
      return selected;
    }catch(err){
      console.error(err);
      setBungieStatus('Failed to load memberships: ' + (err?.message || err), 'error');
    }
  }

  async function loadArmorFromBungie(options={}){
    if(bungieIsFetching) return false;
    const reason = options?.reason || 'manual';
    let success = false;
    try{
      bungieIsFetching = true;
      updateBungieUI();
      const membership = getSelectedMembership();
      if(!membership){
        setBungieStatus('Select a Destiny profile before loading armor.', 'error');
        return false;
      }
      const startMessage = reason === 'manual' ? 'Refreshing armor from Bungieâ€¦' : 'Loading armor from Bungieâ€¦';
      setBungieStatus(startMessage, 'loading');
      const profile = await bungieApiRequest(`/Destiny2/${membership.membershipType}/Profile/${membership.membershipId}/?components=${BUNGIE_COMPONENTS}`);
      const rows = await transformProfileToRows(profile);
      if(!rows.length){
        setBungieStatus('No armor items were found for this profile.', 'error');
        return false;
      }
      STATE.rows = rows;
      saveRows();
      render();
      setUploadHint('Loaded via Bungie API');
      const successMessage = reason === 'manual'
        ? `Refreshed ${rows.length} armor items from Bungie.`
        : `Loaded ${rows.length} armor items from Bungie.`;
      setBungieStatus(successMessage, 'ok');
      if(reason === 'auto'){
        bungieAutoLoadedOnce = true;
      }
      success = true;
    }catch(err){
      console.error(err);
      setBungieStatus('Failed to load armor: ' + (err?.message || err), 'error');
    }finally{
      bungieIsFetching = false;
      updateBungieUI();
    }
    return success;
  }

  async function initBungieIntegration(){
    updateBungieUI();
    await handleOAuthRedirect();
    if(bungieTokens?.refreshToken){
      const refreshValid = Date.now() < ((bungieTokens.refreshTokenExpires || 0) - 60000);
      if(!refreshValid){
        clearBungieTokens(false);
        setBungieStatus('Your Bungie session expired. Please sign in again.', 'error');
        return;
      }
      try{
        await ensureAccessToken();
        let membership = getSelectedMembership();
        if(!membership){
          membership = await fetchMemberships();
        }else{
          renderMembershipOptions();
        }
        if(membership && !bungieAutoLoadedOnce){
          const loaded = await loadArmorFromBungie({ reason: 'auto' });
          if(!loaded && !bungieStatusEl?.textContent){
            setBungieStatus(`Signed in as ${membership.label}. Use Refresh armor to try again.`, 'info');
          }
        }else if(membership && !bungieStatusEl?.textContent){
          setBungieStatus(`Signed in as ${membership.label}.`, 'ok');
        }
      }catch(err){
        console.error(err);
        clearBungieTokens(false);
        setBungieStatus('Your Bungie session expired. Please sign in again.', 'error');
      }
    }else if(!bungieStatusEl?.textContent){
      setBungieStatus('Sign in with Bungie to sync your armor automatically.', 'info');
    }
  }
  // ====== Grouping & Sorting ======
  function clusterRows(filtered){
    const byKey = new Map();
    for(const r of filtered){
      const k = r.Rarity==='Exotic' ? `${r.Type}|${normName(r.Name)}` : r.Type; // exotics cluster by name
      if(!byKey.has(k)) byKey.set(k,[]);
      byKey.get(k).push({...r});
    }
    const out=[]; const A='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for(const [key,items] of byKey){
      const assigned = Array(items.length).fill(false);
      const rawGroups = [];
      for(let i=0;i<items.length;i++){
        if(assigned[i]) continue;
        const grp=[i]; assigned[i]=true;
        for(let j=i+1;j<items.length;j++){
          if(assigned[j]) continue;
          if(STATE.sameNameOnly && normName(items[i].Name)!==normName(items[j].Name)) continue;
          if(similarTop3(items[i],items[j],STATE.tol)){ grp.push(j); assigned[j]=true; }
        }
        rawGroups.push(grp);
      }
      // Order groups by best total first, then id to stabilize
      rawGroups.sort((g1,g2)=>{
        const best1 = Math.max(...g1.map(ix=>num(items[ix]["Total (Base)"])));
        const best2 = Math.max(...g2.map(ix=>num(items[ix]["Total (Base)"])));
        if(best1!==best2) return best2-best1;
        return String(items[g1[0]].Id).localeCompare(String(items[g2[0]].Id));
      });
      const isExoticKey = key.includes('|');
      let letterIdx = 0;
      for(const grp of rawGroups){
        const first = items[grp[0]];
        let label = 'X';
        if(grp.length > 1) {
          const letter = A[Math.min(letterIdx, A.length-1)];
          if(isExoticKey) {
            label = `âš ï¸ðŸŸ¡${slotNumber(first.Type)}${letter}`;
          } else {
            label = `âš ï¸${slotNumber(first.Type)}${letter}`;
          }
          letterIdx++;
        }
        for(const gi of grp){
          const it = items[gi];
          const rank = it.Rarity==='Exotic' ? starsExotic(it["Total (Base)"]) : starsLegendary(it["Total (Base)"]); 
          out.push({ 
            ...it, 
            GroupKey:key, 
            Dupe_Group:label, 
            Rank:rank, 
            RankScore:rankScore(rank), 
            Is_Dupe: label!=='X',
            Is_Dupe_Exotic: (it.Rarity==='Exotic' && label!=='X') // <-- Add this flag
          });
        }
      }
    }
    // Final sort: 
out.sort((a, b) => {
  // 1. Slot order
  const sa = slotNumber(a.Type), sb = slotNumber(b.Type);
  if (sa !== sb) return sa - sb;

  // 2. Legendary before Exotic
  const ra = a.Rarity === "Legendary" ? 0 : 1;
  const rb = b.Rarity === "Legendary" ? 0 : 1;
  if (ra !== rb) return ra - rb;

  // 3. Dupe group first within each rarity
  const da = a.Dupe_Group !== "X";
  const db = b.Dupe_Group !== "X";
  if (da !== db) return db - da; // true first

  // 4. For dupe groups: group label, then rank desc, then total desc, then id
  if (da && db) {
    // Group by group key (for exotics, this is name+type)
    if (a.GroupKey !== b.GroupKey) return String(a.GroupKey).localeCompare(String(b.GroupKey));
    if (a.Dupe_Group !== b.Dupe_Group) return String(a.Dupe_Group).localeCompare(String(b.Dupe_Group));
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // 5. For exotics: after dupe groups, show non-grouped exotics of same name below groups
  if (a.Rarity === "Exotic" && b.Rarity === "Exotic") {
    // GroupKey for exotics is type|name
    if (a.GroupKey !== b.GroupKey) return String(a.GroupKey).localeCompare(String(b.GroupKey));
    // Non-grouped exotics of same name (Dupe_Group === "X") come after grouped
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // 6. For legendaries: non-dupes by name, then rank desc, then total desc, then id
  if (a.Rarity === "Legendary" && b.Rarity === "Legendary") {
    const na = String(a.Name).toLowerCase(), nb = String(b.Name).toLowerCase();
    if (na !== nb) return na.localeCompare(nb);
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // Fallback: by id
  return String(a.Id).localeCompare(String(b.Id));
});
    return out;
  }

  // ====== Render ======
  function render(){
  updateShadowColor(); 
    const tolEl=document.getElementById('tol'); if(tolEl) tolEl.value = STATE.tol;
    initFilters();

    const grouped = getFiltered();

    // Build group->ids for copy-all
    const groupToIds = new Map();
    for(const it of grouped){ if(it.Dupe_Group==='X') continue; const key=`${it.GroupKey||''}::${it.Dupe_Group}`; if(!groupToIds.has(key)) groupToIds.set(key,[]); groupToIds.get(key).push(normId(it.Id)); }

    const host=document.getElementById('rows');
    const empty=document.getElementById('empty');
    host.innerHTML='';
    if(grouped.length===0){ if(empty) empty.style.display='block'; return; } else { if(empty) empty.style.display='none'; }

    let lastGroup = null;
    let altToggle = false;
    for(const it of grouped){
      // Alternate shade when group changes (by Dupe_Group label)
      if (it.Dupe_Group !== lastGroup) {
        altToggle = !altToggle;
        lastGroup = it.Dupe_Group;
      }
      const row=document.createElement('div');
      row.className = 'row item ' + (altToggle ? 'altA' : 'altB');
      // Tag emoji (DIM tag)
      const cTag = document.createElement('div');
      cTag.className = 'center';
      const tag = (it.Tag || '').toLowerCase();
      cTag.textContent = TAG_EMOJIS[tag] || '';
      cTag.title = TAG_LABELS[tag] || '';
      // Item
      const cItem=document.createElement('div');
      cItem.innerHTML=`<div style="font-weight:700">${it.Name}</div>
        <div class="itemmeta">
          ${(["Warlock Bond","Hunter Cloak","Titan Mark"].includes(it.Type)?"Class Item":it.Type)}
          â€¢ ${it.Equippable}
          â€¢ <img src="${RARITY_ICONS[it.Rarity] || ''}" alt="${it.Rarity}" title="${it.Rarity}" style="height:1em;vertical-align:middle;">
        </div>
        <div class="tiny mono">${normId(it.Id)}</div>`;
      // Tier
      const cTier=document.createElement('div'); 
      cTier.className='tier'; 
      const tVal = Number.isFinite(it.Tier) ? Number(it.Tier) : 0; 
      cTier.textContent = 'â™¦'.repeat(Math.max(1, Math.min(5, tVal)));
      // Stats chips
      const cStats=document.createElement('div'); cStats.className='chips';
      for(const k of STAT_COLS){
        const pill=document.createElement('span'); pill.className=`chipStat ${statColorCls(it[k])}`; pill.title=k.replace(' (Base)','');
        const img=document.createElement('img'); img.className='stat-ico'; img.alt=k; img.src=STAT_ICONS[k]||''; if(img.src) pill.appendChild(img);
        const strong=document.createElement('strong'); strong.className='mono'; strong.textContent=String(it[k]||0); pill.appendChild(strong);
        cStats.appendChild(pill);
      }
      // Total
      const cTotal=document.createElement('div'); cTotal.className='center'; cTotal.style.fontWeight='700'; cTotal.textContent=String(it["Total (Base)"]||0);
      // Group (click to copy all group ids)
      const cGroup=document.createElement('div'); cGroup.className='center';
      if(it.Dupe_Group!=='X'){
        const label = it.Dupe_Group;
        const key=`${it.GroupKey||''}::${it.Dupe_Group}`;
        const list=(groupToIds.get(key)||[]).map(id=>`id:${id}`).join(' or ');
        const span=document.createElement('span'); 
        span.className='badge-warn'; 
        span.title='Click to copy all IDs in this dupe group';

        // PATCH: replace ðŸŸ¡ in label with a rarity <img> for Exotic groups by assembling DOM nodes
        // We keep label text (which might contain âš ï¸ðŸŸ¡1A, etc.) but we render the icon instead of the ðŸŸ¡
        // Detect exotic dupe groups using the label pattern OR the item's rarity
        const exoticGroup = /ðŸŸ¡/.test(label) || it.Rarity === 'Exotic';
        if (exoticGroup && RARITY_ICONS[it.Rarity]) {
          // Split off the visible prefix before slot/letter (remove the emoji if present)
          const textNoYellow = label.replace('ðŸŸ¡','');
          // Optional: if the label still includes the âš ï¸, we keep it in text
          // Prepend the icon after âš ï¸
          const m = textNoYellow.match(/^(âš ï¸)?(.*)$/);
          const prefix = (m && m[1]) ? 'âš ï¸' : '';
          const rest = (m && m[2]) ? m[2] : textNoYellow;
          if (prefix) span.append(prefix);

          const img = new Image();
          img.src = RARITY_ICONS[it.Rarity];
          img.alt = it.Rarity;
          img.title = it.Rarity;
          img.style.height = '1em';
          img.style.verticalAlign = 'middle';
          img.style.marginRight = '4px';
          span.appendChild(img);

          span.append(rest);
        } else {
          // Fallback: plain text
          span.append(label);
        }
        span.addEventListener('click', async ()=>{ const ok=await copyTextSafe(list); if(!ok) alert('Copy failed'); });
        cGroup.appendChild(span);
      } else {
        cGroup.innerHTML = `<span class='badge-ok'>âœ…</span>`;
      }
      // Rank
      const cRank=document.createElement('div'); cRank.className='center'; cRank.textContent=it.Rank||'';
      // Copy single id
      const cCopy=document.createElement('div'); cCopy.className='center';
      const btn=document.createElement('button'); btn.className='btn'; btn.textContent='Copy id';
      btn.addEventListener('click', async ()=>{ const ok=await copyTextSafe(`id:${normId(it.Id)}`); btn.textContent= ok? 'Copied!' : 'Copy id'; setTimeout(()=> btn.textContent='Copy id', 1200); });
      cCopy.appendChild(btn);

      row.append(cTag,cItem,cTier,cStats,cTotal,cGroup,cRank,cCopy);
      host.appendChild(row);
    }
  }

  // ====== Events ======
  bungieStatusEl = document.getElementById('bungieStatus');
  bungieMembershipSelect = document.getElementById('membershipSelect');
  bungieMembershipWrap = document.getElementById('membershipSelectWrap');
  bungieLoginBtn = document.getElementById('bungieLogin');
  bungieRefreshBtn = document.getElementById('bungieRefresh');
  bungieLogoutBtn = document.getElementById('bungieLogout');

  if(bungieLoginBtn) bungieLoginBtn.addEventListener('click', () => startBungieAuth());
  if(bungieRefreshBtn) bungieRefreshBtn.addEventListener('click', () => loadArmorFromBungie({ reason: 'manual' }));
  if(bungieLogoutBtn) bungieLogoutBtn.addEventListener('click', () => { clearBungieTokens(true); });
  if(bungieMembershipSelect){
    bungieMembershipSelect.addEventListener('change', (event) => {
      const value = event.target.value;
      if(!value) return;
      const [type, id] = value.split(':');
      bungieConfig.membershipType = Number(type);
      bungieConfig.membershipId = id;
      saveBungieConfig();
      updateBungieUI();
      loadArmorFromBungie({ reason: 'auto' });
    });
  }

  const fileInput = document.getElementById('file');
  const restoreBtn = document.getElementById('restoreBtn');
  const clearBtn = document.getElementById('clearBtn');
  const uploadHint = document.getElementById('uploadHint');
  const uploadTrigger = document.getElementById('uploadTrigger');
  const uploadHintDefault = uploadHint?.dataset?.default ?? (uploadHint?.textContent ?? 'Choose DIM Armor.csv');

  const setUploadHint = (text) => { if (uploadHint) uploadHint.textContent = text; };
  const resetUploadHint = () => setUploadHint(uploadHintDefault);

  if (uploadTrigger && fileInput) {
    uploadTrigger.addEventListener('keydown', (evt) => {
      if (evt.key === 'Enter' || evt.key === ' ') {
        evt.preventDefault();
        fileInput.click();
      }
    });
  }

  if (fileInput) {
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (!f) {
        resetUploadHint();
        return;
      }
      const fileName = f.name || 'Selected file';
      setUploadHint(fileName);
      Papa.parse(f, {
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          const data = res.data || [];
          STATE.rows = data.map((r) => {
            const x = { ...r };
            for (const k of [...STAT_COLS, 'Total (Base)', 'Tier']) {
              if (x[k] !== undefined) {
                const n = num(x[k]);
                x[k] = Number.isFinite(n) ? n : 0;
              }
            }
            x.Id = normId(x.Id);
            return x;
          });
          saveRows();
          render();
          fileInput.value = '';
          setUploadHint(`Loaded â€¢ ${fileName}`);
        },
      });
    });
  }

  if (restoreBtn) {
    restoreBtn.addEventListener('click', () => {
      const rows = loadRows();
      if (rows && Array.isArray(rows)) {
        STATE.rows = rows;
        render();
        resetUploadHint();
      } else {
        alert('No saved CSV found in this browser. Upload a DIM CSV first.');
      }
    });
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      STATE.rows = [];
      localStorage.removeItem(LS_KEY);
      if (fileInput) fileInput.value = '';
      render();
      resetUploadHint();
    });
  }

  document.getElementById('tol').addEventListener('input', (e) => {
    const v = Number(e.target.value);
    STATE.tol = isFinite(v) ? v : STATE.tol;
    render();
  });

  function updateShadowColor() {
  const root = document.documentElement;
  if (STATE.rarityFilter === "Legendary") {
    root.style.setProperty('--shadow', 'var(--shadow-purple)');
  } else if (STATE.rarityFilter === "Exotic") {
    root.style.setProperty('--shadow', 'var(--shadow-gold)');
  } else {
    root.style.setProperty('--shadow', 'var(--shadow-base)');
  }
}

  // Initial
  initBungieIntegration().catch((err)=>{ console.error('Bungie init error', err); });
  const cached = loadRows(); if(cached){ STATE.rows=cached; }
  render();
  updateShadowColor();
</script>
</body>
</html>
