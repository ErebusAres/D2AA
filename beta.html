<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>D2 Armor Analyzer - By ErebusAres</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <link rel="stylesheet" href="beta.css" />

</head>
<body>
  <div class="wrap">
    <header class="panel panel-header">
      <div class="panel-header__layout">
        <div class="panel-header__content">
          <h1>D2 Armor Analyzer</h1>
          <div class="muted">â™¦ Upload your DIM CSV; dupes use topâ€‘3 stat identities within Â± tolerance. Exotics compare only against sameâ€‘name items.</div>
          <div class="muted">â™¦ Click "Restore last" to reload the last uploaded CSV from this browser.</div>
          <div class="muted">â™¦ Click "Copy ID" or A Group Badge to copy to clipboard.</div>
        </div>
        <div class="toolbar">
          <input id="file" type="file" accept=".csv" class="toolbar__input" />
          <label id="uploadTrigger" class="tool-card tool-card--upload" for="file" role="button" tabindex="0">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 4v9" />
                <path d="M9 7l3-3 3 3" />
                <path d="M5 14v6h14v-6" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Upload CSV</span>
              <span class="tool-sub" id="uploadHint" data-default="Choose DIM Armor.csv" aria-live="polite">Choose DIM Armor.csv</span>
            </span>
          </label>
          <button class="tool-card tool-card--restore" id="restoreBtn" type="button" aria-label="Restore last uploaded CSV">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6v6h-6" />
                <path d="M20 12a8 8 0 1 1-8-8" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Restore last</span>
              <span class="tool-sub">Load recent upload</span>
            </span>
          </button>
          <button class="tool-card tool-card--clear" id="clearBtn" type="button" aria-label="Clear all data">
            <span class="tool-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 6h16" />
                <path d="M10 6l1-2h2l1 2" />
                <path d="M7 6l1 14h8l1-14" />
                <path d="M10 11v6" />
                <path d="M14 11v6" />
              </svg>
            </span>
            <span class="tool-copy">
              <span class="tool-title">Clear</span>
              <span class="tool-sub">Remove results</span>
            </span>
          </button>
        </div>
      </div>
    </header>

    <section class="panel panel-auth" id="bungiePanel">
      <div class="auth-header">
        <h2>Connect with Bungie</h2>
        <p class="muted">Sign in with your Bungie account to pull armor automatically, or continue using CSV uploads.</p>
      </div>
      <div class="auth-buttons">
        <button id="bungieLogin" type="button" class="btn btn-primary">Sign in with Bungie</button>
        <button id="bungieRefresh" type="button" class="btn">Refresh armor</button>
        <button id="bungieLogout" type="button" class="btn">Sign out</button>
      </div>
      <div id="membershipSelectWrap" class="auth-membership" style="display:none">
        <label class="auth-field">
          <span class="auth-label">Active profile</span>
          <select id="membershipSelect"></select>
        </label>
      </div>
      <div class="auth-note muted">Tokens are stored locally in this browser only.</div>
      <div id="bungieStatus" class="auth-status muted" aria-live="polite"></div>
    </section>

    <section class="panel panel-auth" id="dimPanel">
      <div class="auth-header">
        <h2>Connect with DIM Sync</h2>
        <p class="muted">Sign in with DIM to layer your item tags on top of Bungie or CSV armor loads.</p>
      </div>
      <div class="auth-grid">
        <label class="auth-field">
          <span class="auth-label">DIM API key</span>
          <input id="dimApiKey" type="text" autocomplete="off" spellcheck="false" placeholder="Paste your dimApiKey" />
        </label>
      </div>
      <div class="auth-buttons">
        <button id="dimLogin" type="button" class="btn btn-primary">Sign in with DIM</button>
        <button id="dimRefresh" type="button" class="btn">Sync DIM tags</button>
        <button id="dimLogout" type="button" class="btn">Disconnect</button>
      </div>
      <div class="auth-note muted">
        Need a key? See the <a href="https://github.com/DestinyItemManager/dim-api" target="_blank" rel="noreferrer noopener">DIM Sync docs</a>. Keys &amp; tokens stay local to this browser.
      </div>
      <div id="dimStatus" class="auth-status muted" aria-live="polite"></div>
    </section>

    <section class="panel panel-debug" id="debugPanel">
      <div class="debug-header">
        <h2>Debug Console</h2>
        <div class="debug-actions">
          <button id="debugToggle" type="button" class="btn btn-small">Show details</button>
          <button id="debugCopy" type="button" class="btn btn-small">Copy snapshot</button>
        </div>
      </div>
      <div id="debugContent" class="debug-content" hidden>
        <div class="debug-section">
          <div class="debug-section__title">Session snapshot</div>
          <pre id="debugSnapshot" class="debug-pre">Collecting stateâ€¦</pre>
        </div>
        <div class="debug-section">
          <div class="debug-section__title">Recent events</div>
          <div id="debugLog" class="debug-log" role="log" aria-live="polite"></div>
        </div>
        <div class="debug-section">
          <div class="debug-section__title">Armor stat breakdown</div>
          <div class="debug-note">First 8 armor rows captured per load. Share this with any bug reports.</div>
          <pre id="debugArmorSamples" class="debug-pre">No armor samples yet â€” load armor from Bungie to capture data.</pre>
        </div>
        <div class="debug-section">
          <label class="debug-section__title" for="debugNotes">Your observations (saved locally)</label>
          <textarea id="debugNotes" class="debug-notes" placeholder="Add steps, timestamps, or anything else that might help troubleshoot issues."></textarea>
          <div class="debug-note muted">Notes never leave this browser â€” copy them with the snapshot when you need to share details.</div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-bottom:16px">
      <div class="filters">
        <div class="line"><span class="label">Class</span><div id="classSeg" class="seg"></div></div>
        <div class="line"><span class="label">Rarity</span><div id="raritySeg" class="seg"></div></div>
        <div class="line"><span class="label">Slot</span><div id="slotSeg" class="seg"></div></div>
        <div class="line"><span class="label">Dupes</span><div id="dupesSeg" class="seg"></div></div>
        <div class="line"><span class="label">Tolerance</span><input id="tol" type="number" min="0" max="20" value="5" style="width:80px"/> <span class="muted">Â± topâ€‘3 stat</span></div>
      </div>
    </section>

    <section class="list">
      <div class="row header">
        <div class="center">Tag</div>
        <div>Item</div>
        <div class="center">Tier</div>
        <div>Base Stats <div class="center-info">(Health, Melee, Grenade, Super, Class, Weapons)</div></div>
        <div class="center">Total</div>
        <div class="center">Group</div>
        <div class="center">Rank</div>
        <div class="right">Copy</div>
      </div>
      <div id="rows"></div>
      <div id="empty" class="empty" style="display:none"><p>
        No items yet â€” upload a DIM CSV or click Restore last.<br/><br/>

        To export from DIM: <br/>
        â™¦ Go to https://app.destinyitemmanager.com/ and sign in. <br/>
        â™¦ Navigate to Organizer. <br/>
        â™¦ Select any class. <br/>
        â™¦ Click the "Armor.csv" button at the top right to download your armor data. <br/>
        â™¦ Upload the downloaded CSV file here. <br/>
      </p></div>
    </section>
  </div>

  <script>
  // ====== Constants ======
  const STAT_COLS = [
    "Health (Base)",
    "Melee (Base)",
    "Grenade (Base)",
    "Super (Base)",
    "Class (Base)",
    "Weapons (Base)"
  ];
  const STAT_ICONS = {
    "Health (Base)":"https://www.bungie.net/common/destiny2_content/icons/717b8b218cc14325a54869bef21d2964.png",
    "Melee (Base)":"https://www.bungie.net/common/destiny2_content/icons/fa534aca76d7f2d7e7b4ba4df4271b42.png",
    "Grenade (Base)":"https://www.bungie.net/common/destiny2_content/icons/065cdaabef560e5808e821cefaeaa22c.png",
    "Super (Base)":"https://www.bungie.net/common/destiny2_content/icons/585ae4ede9c3da96b34086fccccdc8cd.png",
    "Class (Base)":"https://www.bungie.net/common/destiny2_content/icons/7eb845acb5b3a4a9b7e0b2f05f5c43f1.png",
    "Weapons (Base)":"https://www.bungie.net/common/destiny2_content/icons/bc69675acdae9e6b9a68a02fb4d62e07.png"
  };
  const RARITY_ICONS = {
    "Legendary": "https://www.bungie.net/common/destiny2_content/icons/f846f489c2a97afb289b357e431ecf8d.png",
    "Exotic": "https://www.bungie.net/common/destiny2_content/icons/3e6a698e1a8a5fb446fdcbf1e63c5269.png"
  };
  const CLASS_OPTIONS = ["Warlock", "Hunter", "Titan"];
  const SLOT_OPTIONS = ["All", "Helmet", "Gauntlets", "Chest Armor", "Leg Armor", "Class Item"];
  const RARITY_OPTIONS = ["All", "Legendary", "Exotic"];  const DUPES_OPTIONS = ["All", "Only Dupes", "Only Same-Name"];
  const classItemByClass = { Warlock: "Warlock Bond", Hunter: "Hunter Cloak", Titan: "Titan Mark" };
  const DESTINY_ITEM_STATE_MASTERWORK = 1 << 2; // DestinyItemState.Masterwork bit flag
  const TAG_EMOJIS = {
    favorite: "â¤ï¸",
    keep: "ðŸ·ï¸",
    junk: "ðŸš«",
    infuse: "âš¡",
    archive: "ðŸ“¦"
  };
  const TAG_LABELS = {
    favorite: "Favorite",
    keep: "Keep",
    junk: "Junk",
    infuse: "Infuse",
    archive: "Archive"
  };
  const CLASS_ICONS = {
    "Warlock": "https://www.bungie.net/common/destiny2_content/icons/e4006d9a8fe167bd7e83193d7601c89a.png",
    "Hunter":  "https://www.bungie.net/common/destiny2_content/icons/05e32a388d9a65a0ef59b2193eee2db4.png",
    "Titan":   "https://www.bungie.net/common/destiny2_content/icons/46a19ddd00d0f6ca822230943103b54a.png"
  };
  const SLOT_ICONS = {
    "Helmet": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/helmet.svg",
    "Gauntlets": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/gloves.svg",
    "Chest Armor": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/chest.svg",
    "Leg Armor": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/boots.svg",
    "Class Item": "https://raw.githubusercontent.com/justrealmilk/destiny-icons/master/armor_types/class.svg"
  };
  const ARMOR_ARCHETYPES = {
    "Grenadier": "https://www.bungie.net/common/destiny2_content/icons/cbf4f03459ab2818a3d37b7362b2aa93.png", // Grenade, Super
    "Paragon": "https://www.bungie.net/common/destiny2_content/icons/b5feb81f684d767d6212ca138f30b34c.png", // Super, Melee
    "Specialist": "https://www.bungie.net/common/destiny2_content/icons/69731c603d7bcdd0a21b26c711d55f03.png", // Class, Weapons
    "Brawler": "https://www.bungie.net/common/destiny2_content/icons/7bc3bc2bccdafc19dde31f867a06ee9f.png", // Melee, Health
    "Bulwark": "https://www.bungie.net/common/destiny2_content/icons/cda905547dd9eac7a39e6e898f619bc5.png", // Health, Class
    "Gunner": "https://www.bungie.net/common/destiny2_content/icons/15e3b3c25a6d4606dcb887cb67c915a1.png" // Weapons, Grenade
  }
  const CLASS_BY_TYPE = { 0: "Titan", 1: "Hunter", 2: "Warlock", 3: "Unknown", 4: "Any" };
  const ARMOR_BUCKET_HASH_TO_TYPE = {
    3448274439: "Helmet",
    3551918588: "Gauntlets",
    14239492: "Chest Armor",
    20886954: "Leg Armor",
    1585787867: "Class Item"
  };
  const STAT_HASH_TO_LABEL = {
    392767087: "Health (Base)",
    4244567218: "Melee (Base)",
    1735777505: "Grenade (Base)",
    144602215: "Super (Base)",
    1943323491: "Class (Base)",
    2996146975: "Weapons (Base)"
  };
  const ARMOR_INTRINSIC_PLUG_CATEGORY_HASHES = new Set([
    1744546145  // PlugCategoryHashes.Intrinsics
  ]);
  const ARMOR_MOD_PLUG_CATEGORY_HASHES = new Set([
    1202876185, // PlugCategoryHashes.EnhancementsActivity
    640682011,  // PlugCategoryHashes.EnhancementsArms
    383756333,  // PlugCategoryHashes.EnhancementsChest
    1955304674, // PlugCategoryHashes.EnhancementsClass
    744326128,  // PlugCategoryHashes.EnhancementsHead
    1175552225, // PlugCategoryHashes.EnhancementsLegs
    3773173029, // PlugCategoryHashes.EnhancementsArtifice
    1934732343, // PlugCategoryHashes.EnhancementsArtificeExotic
    3422420680, // PlugCategoryHashes.EnhancementsV2Arms
    1526202480, // PlugCategoryHashes.EnhancementsV2Chest
    912441879,  // PlugCategoryHashes.EnhancementsV2ClassItem
    2487827355, // PlugCategoryHashes.EnhancementsV2General
    2912171003, // PlugCategoryHashes.EnhancementsV2Head
    2111701510, // PlugCategoryHashes.EnhancementsV2Legs
    3347429529, // PlugCategoryHashes.EnhancementsUniversal
    3481777685  // core.gear_systems.armor_tiering.plugs.tuning.mods (+Stat / -Stat mods)
  ]);
  const ARMOR_MOD_ITEM_CATEGORY_HASHES = new Set([
    4104513227, // ItemCategoryHashes.ArmorMods
    3723676689, // ItemCategoryHashes.ArmorModsChest
    3196106184, // ItemCategoryHashes.ArmorModsClass
    1037516129, // ItemCategoryHashes.ArmorModsClassHunter
    1650311619, // ItemCategoryHashes.ArmorModsClassTitan
    2955376534, // ItemCategoryHashes.ArmorModsClassWarlock
    3872696960, // ItemCategoryHashes.ArmorModsGauntlets
    1362265421, // ItemCategoryHashes.ArmorModsHelmet
    3607371986, // ItemCategoryHashes.ArmorModsLegs
    4062965806  // ItemCategoryHashes.ArmorModsGameplay
  ]);
  const ARMOR_BASE_SOCKET_CATEGORY_HASHES = new Set([
    3154740035, // SocketCategoryHashes.ArmorPerks_LargePerk (intrinsic stat frames)
    2518356196, // SocketCategoryHashes.ArmorPerks_Reusable
    3956125808  // SocketCategoryHashes.IntrinsicTraits
  ]);
  const ARMOR_MOD_SOCKET_CATEGORY_HASHES = new Set([
    590099826,  // SocketCategoryHashes.ArmorMods
    760375309   // SocketCategoryHashes.ArmorTier (masterwork)
  ]);
  const MEMBERSHIP_TYPE_NAMES = {
    1: "Xbox",
    2: "PlayStation",
    3: "Steam",
    4: "Blizzard",
    5: "Stadia",
    6: "Epic",
    7: "Demon",
    10: "Tiger",
    254: "BungieNet"
  };
  const BUNGIE_CONFIG_STORAGE = 'd2aa_bungie_cfg_v1';
  const BUNGIE_TOKEN_STORAGE = 'd2aa_bungie_tokens_v1';
  const BUNGIE_STATE_STORAGE = 'd2aa_bungie_state_v1';
  const BUNGIE_VERIFIER_STORAGE = 'd2aa_bungie_verifier_v1';
  const BUNGIE_RETURN_STORAGE = 'd2aa_bungie_return_v1';
  const BUNGIE_COMPONENTS = '100,102,200,201,205,300,304,305';
  const BUNGIE_OAUTH_URL = 'https://www.bungie.net/en/OAuth/Authorize';
  const BUNGIE_TOKEN_URL = 'https://www.bungie.net/Platform/App/OAuth/Token/';
  const BUNGIE_API_ROOT = 'https://www.bungie.net/Platform';
  const DIM_CONFIG_STORAGE = 'd2aa_dim_cfg_v1';
  const DIM_TOKEN_STORAGE = 'd2aa_dim_tokens_v1';
  const DIM_PROFILE_STORAGE = 'd2aa_dim_profile_v1';
  const DIM_API_ROOT = 'https://api.destinyitemmanager.com';
  const DIM_APP_VERSION = 'd2aa-beta';
  const BUNGIE_REDIRECT_URI = (() => {
    try {
      const { origin, pathname } = window.location;
      if (!origin || origin === 'null') {
        return 'https://erebusares.github.io/D2AA/beta.html';
      }
      return `${origin}${pathname}`;
    } catch (err) {
      console.warn('Falling back to default Bungie redirect URI', err);
      return 'https://erebusares.github.io/D2AA/beta.html';
    }
  })();
  const BUNGIE_DEFAULT_API_KEY = '96e154014bdd44c0a537e482709b7473';
  const BUNGIE_DEFAULT_CLIENT_ID = '50794';
  const BUNGIE_ALLOWED_ORIGIN = 'https://erebusares.github.io';
  // ====== Helpers ======
  const normId = (s) => (s ? String(s).trim().replace(/^"|"$/g, "") : "");
  const normName = (s) => String(s || "").trim().toLowerCase();
  const num = (v) => (v == null || v === "" ? 0 : Number(v));
  function slotNumber(type){
    if(type === "Helmet") return 1;
    if(type === "Gauntlets") return 2;
    if(type === "Chest Armor") return 3;
    if(type === "Leg Armor") return 4;
    if(["Warlock Bond","Hunter Cloak","Titan Mark"].includes(type)) return 5;
    return 9;
  }
  function starsLegendary(t){ const n=num(t); if(n>=75) return "â˜…â˜…â˜…â˜…â˜…"; if(n===74) return "â˜…â˜…â˜…â˜…â˜†"; if(n===73) return "â˜…â˜…â˜…â˜†â˜†"; if(n===72) return "â˜…â˜…â˜†â˜†â˜†"; if(n===71) return "â˜…â˜†â˜†â˜†â˜†"; return "ðŸ’©"; }
  function starsExotic(t){ const n=num(t); if(n>=63) return "â˜…â˜…â˜…â˜…â˜…"; if(n===62) return "â˜…â˜…â˜…â˜…â˜†"; if(n===61) return "â˜…â˜…â˜…â˜†â˜†"; if(n===60) return "â˜…â˜…â˜†â˜†â˜†"; if(n===59) return "â˜…â˜†â˜†â˜†â˜†"; return "ðŸ’©"; }
  function statColorCls(v){ if(v>=30) return "stat-cyan"; if(v>=24) return "stat-green"; if(v>=15) return "stat-yellow"; return "stat-red"; }
  function top3Entries(item){
    const arr = STAT_COLS.map(k => ({ name:k, value:num(item[k]) }));
    arr.sort((a,b)=> (b.value - a.value) || a.name.localeCompare(b.name));
    return arr.slice(0,3);
  }
  function similarTop3(a,b,tol){
    const ta = top3Entries(a), tb = top3Entries(b);
    for(let i=0;i<3;i++){
      if(ta[i].name !== tb[i].name) return false;
      if(Math.abs(ta[i].value - tb[i].value) > tol) return false;
    }
    return true;
  }
  function rankScore(rank){ if(!rank) return -1; const stars=(rank.match(/â˜…/g)||[]).length; if(stars>0) return stars; return 0; }
  async function copyTextSafe(text){
    try{
      if(navigator.clipboard && window.isSecureContext){ await navigator.clipboard.writeText(text); return true; }
      throw new Error('clipboard api not available');
    }catch(e){
      try{ const ta=document.createElement('textarea'); ta.value=text; ta.setAttribute('readonly',''); ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select(); const ok=document.execCommand('copy'); document.body.removeChild(ta); return ok; }catch(e2){ alert('Copy failed: '+e2); return false; }
    }
  }

  // ====== Debug Panel ======
  const DEBUG_LOG_LIMIT = 200;
  const DEBUG_NOTES_STORAGE = 'd2aa_debug_notes_v1';
  const ARMOR_DEBUG_SAMPLE_LIMIT = 8;
  const debugState = {
    entries: [],
    snapshotText: '',
    snapshotData: null,
    isOpen: false,
    lastStatus: { message: '', type: 'info' },
    dimLastStatus: { message: '', type: 'info' },
    lastUiStateSignature: '',
    copyResetTimer: null,
    lastRenderCount: null,
    armorSamples: []
  };
  const debugEls = {
    panel: null,
    toggle: null,
    copy: null,
    content: null,
    log: null,
    snapshot: null,
    notes: null,
    armor: null
  };

  function safeSerialize(value){
    if(value == null) return '';
    if(typeof value === 'string') return value;
    try{
      return JSON.stringify(value, null, 2);
    }catch(err){
      return String(value);
    }
  }

  function escapeHtml(value){
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function maskSecret(value){
    if(!value) return null;
    const str = String(value);
    if(str.length <= 4) return 'â€¢â€¢â€¢â€¢';
    const visible = str.slice(-4);
    return `${'â€¢'.repeat(Math.max(0, str.length - 4))}${visible}`;
  }

  function loadDebugNotes(){
    try{
      return localStorage.getItem(DEBUG_NOTES_STORAGE) || '';
    }catch(err){
      console.warn('Failed to load debug notes', err);
      return '';
    }
  }

  function saveDebugNotes(notes){
    try{
      if(notes && notes.trim()){
        localStorage.setItem(DEBUG_NOTES_STORAGE, notes);
      }else{
        localStorage.removeItem(DEBUG_NOTES_STORAGE);
      }
    }catch(err){
      console.warn('Failed to persist debug notes', err);
    }
  }

  function renderDebugLog(){
    if(!debugEls.log){
      return;
    }
    if(!debugState.entries.length){
      debugEls.log.innerHTML = '<div class="debug-empty">No debug events yet.</div>';
      return;
    }
    const items = [...debugState.entries].reverse().map((entry) => {
      const detailsHtml = entry.details ? `<div class="debug-entry__details">${escapeHtml(entry.details)}</div>` : '';
      return `<div class="debug-entry"><div class="debug-entry__time">${escapeHtml(entry.timestamp)}</div><div class="debug-entry__message">${escapeHtml(entry.message)}</div>${detailsHtml}</div>`;
    }).join('');
    debugEls.log.innerHTML = items;
  }

  function renderDebugArmorSamples(){
    if(!debugEls.armor){
      return;
    }
    if(!debugState.armorSamples.length){
      debugEls.armor.textContent = 'No armor samples yet â€” load armor from Bungie to capture data.';
      return;
    }
    const sections = debugState.armorSamples.map((sample, index) => {
      const header = `#${index + 1} ${sample.name} â€¢ ${sample.type} (Tier ${sample.tier ?? 0})`;
      const payload = {
        instanceId: sample.instanceId,
        itemHash: sample.itemHash,
        energy: sample.energy,
        stats: sample.stats,
        sockets: sample.sockets
      };
      return `${header}\n${safeSerialize(payload)}`;
    }).join('\n\n');
    debugEls.armor.textContent = sections;
  }

  function recordArmorDebugSample(sample){
    if(!sample){
      return;
    }
    debugState.armorSamples.push(sample);
    if(debugState.armorSamples.length > ARMOR_DEBUG_SAMPLE_LIMIT){
      debugState.armorSamples.splice(0, debugState.armorSamples.length - ARMOR_DEBUG_SAMPLE_LIMIT);
    }
    renderDebugArmorSamples();
  }

  function buildDebugSnapshotData(){
    const now = Date.now();
    const selected = bungieMemberships.find((mem) => String(mem.membershipType) === String(bungieConfig?.membershipType) && String(mem.membershipId) === String(bungieConfig?.membershipId)) || null;
    const inventorySize = manifestCache?.inventoryItem instanceof Map ? manifestCache.inventoryItem.size : 0;
    const bucketSize = manifestCache?.bucket instanceof Map ? manifestCache.bucket.size : 0;
    const socketSize = manifestCache?.socketType instanceof Map ? manifestCache.socketType.size : 0;
    return {
      generatedAt: new Date(now).toISOString(),
      status: debugState.lastStatus,
      ui: {
        bungieIsFetching,
        bungieAutoLoadedOnce,
        rowsLoaded: Array.isArray(STATE?.rows) ? STATE.rows.length : 0
      },
      config: {
        clientId: bungieConfig?.clientId || null,
        membershipId: bungieConfig?.membershipId || null,
        membershipType: bungieConfig?.membershipType || null,
        apiKeyMasked: maskSecret(bungieConfig?.apiKey)
      },
      tokens: {
        hasAccessToken: Boolean(bungieTokens?.accessToken),
        hasRefreshToken: Boolean(bungieTokens?.refreshToken),
        accessTokenExpiresInMs: bungieTokens?.accessTokenExpires ? bungieTokens.accessTokenExpires - now : null,
        refreshTokenExpiresInMs: bungieTokens?.refreshTokenExpires ? bungieTokens.refreshTokenExpires - now : null,
        tokenType: bungieTokens?.tokenType || null
      },
      dim: {
        status: debugState.dimLastStatus,
        hasApiKey: Boolean((dimConfig?.apiKey || '').trim()),
        apiKeyMasked: maskSecret(dimConfig?.apiKey),
        lastMembershipId: dimConfig?.lastMembershipId || null,
        hasToken: Boolean(dimTokens?.accessToken),
        tokenExpiresInMs: dimTokens?.expiresAt ? dimTokens.expiresAt - now : null,
        tokenMembershipId: dimTokens?.membershipId || null,
        profile: {
          tagCount: Array.isArray(dimProfile?.tags) ? dimProfile.tags.length : 0,
          itemHashTagCount: Array.isArray(dimProfile?.itemHashTags) ? dimProfile.itemHashTags.length : 0,
          fetchedAt: dimProfile?.fetchedAt || null,
          syncToken: dimSyncToken || null
        }
      },
      memberships: {
        total: bungieMemberships.length,
        selected: selected ? { membershipId: selected.membershipId, membershipType: selected.membershipType, label: selected.label } : null
      },
      manifestCache: {
        inventoryItem: inventorySize,
        bucket: bucketSize,
        socketType: socketSize
      },
      armorSamplesCaptured: debugState.armorSamples.length
    };
  }

  function updateDebugSnapshot(){
    const snapshot = buildDebugSnapshotData();
    debugState.snapshotData = snapshot;
    debugState.snapshotText = safeSerialize(snapshot);
    if(debugEls.snapshot){
      debugEls.snapshot.textContent = debugState.snapshotText;
    }
  }

  function logDebug(message, details){
    const entry = {
      timestamp: new Date().toISOString(),
      message: String(message || 'log'),
      details: safeSerialize(details)
    };
    debugState.entries.push(entry);
    if(debugState.entries.length > DEBUG_LOG_LIMIT){
      debugState.entries.splice(0, debugState.entries.length - DEBUG_LOG_LIMIT);
    }
    renderDebugLog();
  }

  function buildDebugDump(){
    const lines = [];
    lines.push('D2 Armor Analyzer Debug Snapshot');
    lines.push(`Generated: ${new Date().toISOString()}`);
    lines.push('');
    lines.push('--- Snapshot ---');
    lines.push(debugState.snapshotText || safeSerialize(buildDebugSnapshotData()));
    lines.push('');
    lines.push('--- Recent events ---');
    if(debugState.entries.length){
      for(const entry of debugState.entries){
        lines.push(`${entry.timestamp} :: ${entry.message}`);
        if(entry.details){
          lines.push(entry.details);
        }
        lines.push('');
      }
    }else{
      lines.push('(no events logged)');
    }
    lines.push('--- Notes ---');
    const notesValue = debugEls.notes?.value ?? loadDebugNotes();
    lines.push(notesValue ? notesValue : '(none)');
    return lines.join('\n');
  }

  function setDebugContentOpen(force){
    if(!debugEls.content){
      return;
    }
    const next = force != null ? Boolean(force) : !debugState.isOpen;
    debugState.isOpen = next;
    if(next){
      debugEls.content.hidden = false;
      debugEls.content.classList.add('is-open');
      if(debugEls.toggle){
        debugEls.toggle.textContent = 'Hide details';
      }
    }else{
      debugEls.content.hidden = true;
      debugEls.content.classList.remove('is-open');
      if(debugEls.toggle){
        debugEls.toggle.textContent = 'Show details';
      }
    }
  }

  function initDebugPanel(){
    debugEls.panel = document.getElementById('debugPanel');
    if(!debugEls.panel){
      return;
    }
    debugEls.toggle = document.getElementById('debugToggle');
    debugEls.copy = document.getElementById('debugCopy');
    debugEls.content = document.getElementById('debugContent');
    debugEls.log = document.getElementById('debugLog');
    debugEls.snapshot = document.getElementById('debugSnapshot');
    debugEls.notes = document.getElementById('debugNotes');
    debugEls.armor = document.getElementById('debugArmorSamples');
    if(debugEls.toggle){
      debugEls.toggle.addEventListener('click', () => {
        setDebugContentOpen();
        updateDebugSnapshot();
      });
    }
    if(debugEls.copy){
      debugEls.copy.addEventListener('click', async () => {
        const dump = buildDebugDump();
        const ok = await copyTextSafe(dump);
        if(debugState.copyResetTimer){
          clearTimeout(debugState.copyResetTimer);
          debugState.copyResetTimer = null;
        }
        if(ok){
          debugEls.copy.textContent = 'Copied!';
        }else{
          debugEls.copy.textContent = 'Copy failed';
        }
        debugState.copyResetTimer = setTimeout(() => {
          debugEls.copy.textContent = 'Copy snapshot';
        }, 2000);
      });
    }
    if(debugEls.notes){
      debugEls.notes.value = loadDebugNotes();
      debugEls.notes.addEventListener('input', (event) => {
        saveDebugNotes(event.target.value);
      });
    }
    renderDebugLog();
    renderDebugArmorSamples();
    updateDebugSnapshot();
    setDebugContentOpen(false);
    logDebug('Debug panel initialized');
  }

  // ====== State & Storage ======
  let STATE = {
    rows:[],
    classFilter:'Warlock',
    slotFilter:'All',
    rarityFilter:'All',
    tol:5,
    dupesFilter:'All' // NEW
  };
  const LS_KEY = 'd2_armor_rows_v1';
  let bungieConfig = loadBungieConfig();
  let bungieTokens = loadBungieTokens();
  let bungieMemberships = [];
  let bungieIsFetching = false;
  let bungieAutoLoadedOnce = false;
  let dimConfig = loadDimConfig();
  let dimTokens = loadDimTokens();
  let dimProfile = loadDimProfileCache();
  let dimSyncToken = dimProfile?.syncToken ?? null;
  let dimIsFetching = false;
  const manifestCache = {
    inventoryItem: new Map(),
    bucket: new Map(),
    socketType: new Map()
  };
  const MANIFEST_COMPONENT_INVENTORY_ITEM = 'DestinyInventoryItemDefinition';
  const MANIFEST_COMPONENT_SOCKET_TYPE = 'DestinySocketTypeDefinition';
  let manifestIndexPromise = null;
  const manifestComponentCache = new Map();
  const manifestComponentPromises = new Map();
  let bungieStatusEl = null;
  let bungieMembershipSelect = null;
  let bungieMembershipWrap = null;
  let bungieLoginBtn = null;
  let bungieRefreshBtn = null;
  let bungieLogoutBtn = null;
  let dimStatusEl = null;
  let dimLoginBtn = null;
  let dimRefreshBtn = null;
  let dimLogoutBtn = null;
  let dimApiKeyInput = null;
  const rowBaseTags = new Map();
  function saveRows(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(STATE.rows)); }catch(_){} }
  function loadRows(){ try{ const s=localStorage.getItem(LS_KEY); if(!s) return null; return JSON.parse(s); }catch(_){ return null; } }

  // ====== Filters UI ======
  function makeSeg(containerId, options, key){
  const el = document.getElementById(containerId); if(!el) return; el.innerHTML='';
  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'chip' + (STATE[key]===opt ? ' active' : '');
    let label = opt;
    // Add icons for class, rarity, and slot filters
    if (containerId === 'classSeg' && CLASS_ICONS[opt]) {
      label = `<span class="chip-icon-mask" style="mask-image:url('${CLASS_ICONS[opt]}');-webkit-mask-image:url('${CLASS_ICONS[opt]}');"></span>${opt}`;
    }
    if (containerId === 'raritySeg' && RARITY_ICONS[opt]) {
      label = `<img src="${RARITY_ICONS[opt]}" alt="${opt}" title="${opt}" class="chip-icon rarity" style="height:1em;vertical-align:middle;margin-right:4px;">${opt}`;
    }
    if (containerId === 'slotSeg' && SLOT_ICONS[opt]) {
      label = `<span class="chip-icon-mask" style="mask-image:url('${SLOT_ICONS[opt]}');-webkit-mask-image:url('${SLOT_ICONS[opt]}');"></span>${opt}`;
    }
    btn.innerHTML = (STATE[key]===opt? 'â— ' : 'â—‹ ') + label;
    btn.addEventListener('click', ()=>{ STATE[key]=opt; render(); makeSeg(containerId, options, key); });
    el.appendChild(btn);
  });
}
  function initFilters(){
    makeSeg('classSeg', CLASS_OPTIONS, 'classFilter');
    makeSeg('raritySeg', RARITY_OPTIONS, 'rarityFilter');
    makeSeg('slotSeg',   SLOT_OPTIONS,   'slotFilter');
    makeSeg('dupesSeg',  DUPES_OPTIONS,  'dupesFilter'); // NEW
  }

  // ====== Data selection ======
  function getFiltered(){
  const expected = classItemByClass[STATE.classFilter];
  // Always group on the full set for dupe logic
  let baseFiltered = STATE.rows.filter(r =>
    (STATE.classFilter ? r.Equippable === STATE.classFilter : true) &&
    (STATE.slotFilter==='All' ? true : STATE.slotFilter==='Class Item' ? r.Type===expected : r.Type===STATE.slotFilter) &&
    (STATE.rarityFilter==='All' ? true : r.Rarity === STATE.rarityFilter)
  );
  // Get all grouped rows for this filtered set
  const grouped = clusterRows(baseFiltered);

  if (STATE.dupesFilter === "Only Dupes") {
    // Show only items in any dupe group (Dupe_Group !== "X")
    return grouped.filter(r => r.Dupe_Group && r.Dupe_Group !== "X");
  } else if (STATE.dupesFilter === "Only Same-Name") {
    // Show only dupe groups where all items share the same name
    // 1. Find all dupe groups
    const dupeGroups = {};
    for (const r of grouped) {
      if (r.Dupe_Group && r.Dupe_Group !== "X") {
        const key = `${r.GroupKey}::${r.Dupe_Group}`;
        if (!dupeGroups[key]) dupeGroups[key] = [];
        dupeGroups[key].push(r);
      }
    }
    // 2. Keep only groups where all items have the same normalized name
    const validIds = new Set();
    for (const group of Object.values(dupeGroups)) {
      const names = new Set(group.map(r => normName(r.Name)));
      if (names.size === 1) {
        for (const r of group) validIds.add(r.Id);
      }
    }
    return grouped.filter(r => validIds.has(r.Id));
  }
  // Default: show all
  return grouped;
}

  // ====== Bungie API Integration ======
  function getDefaultTokenState(){
    return {
      accessToken:null,
      refreshToken:null,
      accessTokenExpires:0,
      refreshTokenExpires:0,
      tokenType:'Bearer',
      membershipId:null,
      membershipType:null
    };
  }

  function loadBungieConfig(){
    const defaults = {
      apiKey: BUNGIE_DEFAULT_API_KEY,
      clientId: BUNGIE_DEFAULT_CLIENT_ID,
      membershipId: null,
      membershipType: null
    };
    try{
      const raw = localStorage.getItem(BUNGIE_CONFIG_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return {
        apiKey: BUNGIE_DEFAULT_API_KEY,
        clientId: BUNGIE_DEFAULT_CLIENT_ID,
        membershipId: parsed?.membershipId ?? null,
        membershipType: parsed?.membershipType ?? null
      };
    }catch(err){
      console.warn('Failed to parse Bungie config', err);
      return { ...defaults };
    }
  }

  function saveBungieConfig(){
    try{
      const payload = {
        membershipId: bungieConfig?.membershipId ?? null,
        membershipType: bungieConfig?.membershipType ?? null
      };
      localStorage.setItem(BUNGIE_CONFIG_STORAGE, JSON.stringify(payload));
    }catch(err){
      console.warn('Failed to persist Bungie config', err);
    }
    logDebug('saveBungieConfig', {
      membershipId: bungieConfig?.membershipId ?? null,
      membershipType: bungieConfig?.membershipType ?? null
    });
    updateDebugSnapshot();
  }

  function ensureBungieConfigDefaults(){
    if(!bungieConfig) bungieConfig = loadBungieConfig();
    bungieConfig.apiKey = BUNGIE_DEFAULT_API_KEY;
    bungieConfig.clientId = BUNGIE_DEFAULT_CLIENT_ID;
    if(bungieConfig.membershipId == null) bungieConfig.membershipId = null;
    if(bungieConfig.membershipType == null) bungieConfig.membershipType = null;
  }

  function loadBungieTokens(){
    const defaults = getDefaultTokenState();
    try{
      const raw = localStorage.getItem(BUNGIE_TOKEN_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return { ...defaults, ...parsed };
    }catch(err){
      console.warn('Failed to load Bungie tokens', err);
      return { ...defaults };
    }
  }

  function saveBungieTokens(){
    const hasAccessToken = Boolean(bungieTokens?.accessToken);
    const hasRefreshToken = Boolean(bungieTokens?.refreshToken);
    try{
      if(!hasAccessToken && !hasRefreshToken){
        localStorage.removeItem(BUNGIE_TOKEN_STORAGE);
      }else{
        localStorage.setItem(BUNGIE_TOKEN_STORAGE, JSON.stringify(bungieTokens));
      }
    }catch(err){
      console.warn('Failed to persist Bungie tokens', err);
    }
    logDebug('saveBungieTokens', {
      hasAccessToken,
      hasRefreshToken
    });
    updateDebugSnapshot();
  }

  function clearBungieTokens(showMessage){
    bungieTokens = getDefaultTokenState();
    bungieMemberships = [];
    bungieAutoLoadedOnce = false;
    localStorage.removeItem(BUNGIE_TOKEN_STORAGE);
    renderMembershipOptions();
    updateBungieUI();
    if(showMessage){
      setBungieStatus('Signed out. You can still upload CSV files manually.', 'info');
    }
    logDebug('clearBungieTokens', { showMessage: Boolean(showMessage) });
    updateDebugSnapshot();
  }

  // ====== DIM Sync storage ======
  function loadDimConfig(){
    const defaults = {
      apiKey: '',
      lastMembershipId: null
    };
    try{
      const raw = localStorage.getItem(DIM_CONFIG_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return {
        ...defaults,
        apiKey: typeof parsed?.apiKey === 'string' ? parsed.apiKey : '',
        lastMembershipId: parsed?.lastMembershipId ?? null
      };
    }catch(err){
      console.warn('Failed to load DIM config', err);
      return { ...defaults };
    }
  }

  function saveDimConfig(){
    try{
      const payload = {
        apiKey: (dimConfig?.apiKey || '').trim(),
        lastMembershipId: dimConfig?.lastMembershipId ?? null
      };
      if(!payload.apiKey && !payload.lastMembershipId){
        localStorage.removeItem(DIM_CONFIG_STORAGE);
      }else{
        localStorage.setItem(DIM_CONFIG_STORAGE, JSON.stringify(payload));
      }
    }catch(err){
      console.warn('Failed to persist DIM config', err);
    }
    logDebug('saveDimConfig', {
      hasApiKey: Boolean((dimConfig?.apiKey || '').trim()),
      lastMembershipId: dimConfig?.lastMembershipId ?? null
    });
    updateDebugSnapshot();
  }

  function loadDimTokens(){
    try{
      const raw = localStorage.getItem(DIM_TOKEN_STORAGE);
      if(!raw) return null;
      const parsed = JSON.parse(raw);
      if(!parsed?.accessToken) return null;
      const expiresAt = Number(parsed.expiresAt || parsed.expires || 0);
      return {
        accessToken: String(parsed.accessToken),
        expiresAt: Number.isFinite(expiresAt) ? expiresAt : 0,
        membershipId: parsed?.membershipId ? String(parsed.membershipId) : null
      };
    }catch(err){
      console.warn('Failed to load DIM tokens', err);
      return null;
    }
  }

  function saveDimTokens(){
    try{
      if(!dimTokens?.accessToken){
        localStorage.removeItem(DIM_TOKEN_STORAGE);
      }else{
        localStorage.setItem(DIM_TOKEN_STORAGE, JSON.stringify(dimTokens));
      }
    }catch(err){
      console.warn('Failed to persist DIM tokens', err);
    }
    logDebug('saveDimTokens', {
      hasAccessToken: Boolean(dimTokens?.accessToken),
      expiresAt: dimTokens?.expiresAt ?? null,
      membershipId: dimTokens?.membershipId ?? null
    });
    updateDebugSnapshot();
  }

  function clearDimTokens(showMessage){
    dimTokens = null;
    localStorage.removeItem(DIM_TOKEN_STORAGE);
    if(showMessage){
      setDimStatus('DIM session cleared. You can reconnect any time.', 'info');
    }
    updateDimUI();
    logDebug('clearDimTokens', { showMessage: Boolean(showMessage) });
    updateDebugSnapshot();
  }

  function loadDimProfileCache(){
    const defaults = {
      tags: [],
      itemHashTags: [],
      fetchedAt: null,
      syncToken: null
    };
    try{
      const raw = localStorage.getItem(DIM_PROFILE_STORAGE);
      if(!raw) return { ...defaults };
      const parsed = JSON.parse(raw);
      return {
        tags: Array.isArray(parsed?.tags) ? parsed.tags : [],
        itemHashTags: Array.isArray(parsed?.itemHashTags) ? parsed.itemHashTags : [],
        fetchedAt: parsed?.fetchedAt ?? null,
        syncToken: parsed?.syncToken ?? null
      };
    }catch(err){
      console.warn('Failed to load cached DIM profile', err);
      return { ...defaults };
    }
  }

  function saveDimProfileCache(){
    try{
      if(dimProfile && (dimProfile.tags?.length || dimProfile.itemHashTags?.length || dimProfile.syncToken)){
        localStorage.setItem(DIM_PROFILE_STORAGE, JSON.stringify(dimProfile));
      }else{
        localStorage.removeItem(DIM_PROFILE_STORAGE);
      }
    }catch(err){
      console.warn('Failed to persist DIM profile cache', err);
    }
    updateDebugSnapshot();
  }

  function clearDimProfile(showMessage){
    dimProfile = { tags: [], itemHashTags: [], fetchedAt: null, syncToken: null };
    dimSyncToken = null;
    localStorage.removeItem(DIM_PROFILE_STORAGE);
    if(showMessage){
      setDimStatus('DIM profile cache cleared.', 'info');
    }
    applyDimProfileToRows({ render: true });
    logDebug('clearDimProfile', { showMessage: Boolean(showMessage) });
    updateDebugSnapshot();
  }

  function hasValidDimToken(){
    if(!dimTokens?.accessToken) return false;
    const expiresAt = Number(dimTokens?.expiresAt || 0);
    if(!expiresAt) return true;
    return Date.now() < (expiresAt - 60000);
  }

  function updateDimUI(){
    const hasKey = Boolean((dimConfig?.apiKey || '').trim());
    const bungieReady = Boolean(bungieTokens?.refreshToken);
    const tokenValid = hasValidDimToken();
    if(dimApiKeyInput && document.activeElement !== dimApiKeyInput){
      dimApiKeyInput.value = dimConfig?.apiKey || '';
    }
    if(dimLoginBtn) dimLoginBtn.disabled = dimIsFetching || !hasKey || !bungieReady;
    if(dimRefreshBtn) dimRefreshBtn.disabled = dimIsFetching || !tokenValid;
    if(dimLogoutBtn) dimLogoutBtn.disabled = dimIsFetching || !dimTokens?.accessToken;
    updateDebugSnapshot();
  }

  function setDimStatus(message, type='info'){
    const normalizedMessage = message || '';
    const changed = debugState.dimLastStatus.message !== normalizedMessage || debugState.dimLastStatus.type !== type;
    debugState.dimLastStatus = { message: normalizedMessage, type };
    if(changed){
      logDebug('dimStatus', { message: normalizedMessage, type });
      updateDebugSnapshot();
    }
    if(!dimStatusEl) return;
    dimStatusEl.textContent = normalizedMessage;
    dimStatusEl.classList.remove('status-ok','status-error','status-loading');
    const isInfo = !normalizedMessage || type === 'info';
    dimStatusEl.classList.toggle('muted', isInfo);
    if(type === 'ok') dimStatusEl.classList.add('status-ok');
    else if(type === 'error') dimStatusEl.classList.add('status-error');
    else if(type === 'loading') dimStatusEl.classList.add('status-loading');
  }

  async function ensureDimAccessToken(){
    if(hasValidDimToken()){
      return dimTokens.accessToken;
    }
    return requestDimToken();
  }

  async function requestDimToken(){
    if(!(dimConfig?.apiKey && dimConfig.apiKey.trim())){
      throw new Error('Add a DIM API key first.');
    }
    const membership = getSelectedMembership();
    const membershipId = membership?.membershipId || bungieConfig?.membershipId || bungieTokens?.membershipId;
    if(!membershipId){
      throw new Error('Select a Bungie profile before connecting to DIM.');
    }
    if(dimTokens?.membershipId && String(dimTokens.membershipId) !== String(membershipId)){
      clearDimTokens(false);
    }
    await ensureAccessToken();
    let response;
    try{
      response = await fetch(`${DIM_API_ROOT}/auth/token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': dimConfig.apiKey.trim(),
          'X-DIM-Version': DIM_APP_VERSION
        },
        body: JSON.stringify({
          bungieAccessToken: bungieTokens?.accessToken || '',
          membershipId: String(membershipId)
        })
      });
    }catch(err){
      logDebug('dimAuth networkError', { error: err?.message || err });
      throw new Error(formatDimNetworkError(err));
    }
    const data = await response.json().catch(()=>null);
    if(!response.ok){
      if(response.status === 401){
        clearDimTokens(false);
      }
      const message = data?.error && data?.message ? `${data.error}: ${data.message}` : `DIM auth failed (HTTP ${response.status})`;
      throw new Error(message);
    }
    if(!data?.accessToken){
      throw new Error('DIM auth response missing accessToken.');
    }
    const expiresInSeconds = Number(data?.expiresInSeconds || 0);
    const expiresAt = Number.isFinite(expiresInSeconds) && expiresInSeconds > 0
      ? Date.now() + expiresInSeconds * 1000
      : 0;
    dimTokens = {
      accessToken: data.accessToken,
      expiresAt,
      membershipId: String(membershipId)
    };
    saveDimTokens();
    updateDimUI();
    logDebug('dimAuth success', {
      membershipId: String(membershipId),
      expiresInSeconds: Number.isFinite(expiresInSeconds) ? expiresInSeconds : null
    });
    return dimTokens.accessToken;
  }

  function buildDimRequestHeaders(accessToken){
    const headers = new Headers();
    headers.set('X-API-Key', dimConfig?.apiKey?.trim() || '');
    headers.set('X-DIM-Version', DIM_APP_VERSION);
    headers.set('Authorization', `Bearer ${accessToken}`);
    return headers;
  }

  async function dimApiRequest(path, options={}){
    if(!(dimConfig?.apiKey && dimConfig.apiKey.trim())){
      throw new Error('Add a DIM API key first.');
    }
    const accessToken = await ensureDimAccessToken();
    const url = new URL(`${DIM_API_ROOT}${path}`);
    if(options?.params){
      for(const [key,value] of Object.entries(options.params)){
        if(value == null) continue;
        url.searchParams.set(key, String(value));
      }
    }
    const headers = buildDimRequestHeaders(accessToken);
    if(options?.headers){
      for(const [key,value] of Object.entries(options.headers)){
        headers.set(key, value);
      }
    }
    let body = options?.body;
    if(body && typeof body !== 'string'){
      headers.set('Content-Type', headers.get('Content-Type') || 'application/json');
      body = JSON.stringify(body);
    }
    let response;
    try{
      response = await fetch(url.toString(), {
        method: options?.method || 'GET',
        headers,
        body
      });
    }catch(err){
      logDebug('dimApiRequest networkError', { path, error: err?.message || err });
      throw new Error(formatDimNetworkError(err));
    }
    const hasBody = response.status !== 204;
    const data = hasBody ? await response.json().catch(()=>null) : null;
    if(!response.ok){
      if(response.status === 401){
        clearDimTokens(false);
      }
      const message = data?.error && data?.message ? `${data.error}: ${data.message}` : `DIM request failed (HTTP ${response.status})`;
      throw new Error(message);
    }
    return data;
  }

  async function syncDimProfile(options={}){
    const reason = options?.reason || 'manual';
    const silent = Boolean(options?.silent);
    if(dimIsFetching){
      logDebug('syncDimProfile skipped', { reason, dimIsFetching: true });
      return false;
    }
    if(!(dimConfig?.apiKey && dimConfig.apiKey.trim())){
      setDimStatus('Add a DIM API key to enable DIM Sync.', 'error');
      return false;
    }
    const membership = getSelectedMembership();
    const membershipId = membership?.membershipId || bungieConfig?.membershipId || bungieTokens?.membershipId;
    if(!membershipId){
      setDimStatus('Select a Bungie profile before syncing DIM tags.', 'error');
      return false;
    }
    if(dimTokens?.membershipId && String(dimTokens.membershipId) !== String(membershipId)){
      clearDimTokens(false);
    }
    dimIsFetching = true;
    updateDimUI();
    const startMessage = reason === 'auto' ? 'Checking DIM Syncâ€¦' : 'Syncing DIM tagsâ€¦';
    if(!silent){
      setDimStatus(startMessage, 'loading');
    }
    try{
      await ensureAccessToken();
      const params = {
        components: 'tags,hashtags',
        platformMembershipId: String(membershipId),
        destinyVersion: '2'
      };
      if(dimSyncToken && !options?.forceFull){
        params.sync = dimSyncToken;
      }
      const response = await dimApiRequest('/profile', { method: 'GET', params });
      const tags = Array.isArray(response?.tags) ? response.tags : [];
      const itemHashTags = Array.isArray(response?.itemHashTags) ? response.itemHashTags : [];
      dimProfile = {
        tags,
        itemHashTags,
        fetchedAt: Date.now(),
        syncToken: response?.syncToken ?? null
      };
      dimSyncToken = dimProfile.syncToken ?? null;
      dimConfig.lastMembershipId = String(membershipId);
      saveDimConfig();
      saveDimProfileCache();
      const changed = applyDimProfileToRows({ render: false });
      if(changed){
        saveRows();
        render();
      }else if(!silent){
        render();
      }
      const summary = `Synced ${tags.length} DIM tag${tags.length === 1 ? '' : 's'}.`;
      if(!silent){
        setDimStatus(summary, 'ok');
      }
      logDebug('dimSync success', {
        reason,
        tagCount: tags.length,
        itemHashTagCount: itemHashTags.length,
        usedSyncToken: Boolean(dimSyncToken && options?.forceFull !== true)
      });
      updateDebugSnapshot();
      return true;
    }catch(err){
      logDebug('dimSync error', { reason, error: err?.message || err });
      if(!silent){
        setDimStatus('DIM sync failed: ' + (err?.message || err), 'error');
      }
      return false;
    }finally{
      dimIsFetching = false;
      updateDimUI();
    }
  }

  function resetBaseTags(rows){
    rowBaseTags.clear();
    if(!Array.isArray(rows)) return;
    for(const row of rows){
      const id = normId(row?.Id);
      const base = typeof row?.Tag === 'string' ? row.Tag : (row?.Tag ?? '');
      rowBaseTags.set(id, base || '');
      row.Tag = base || '';
    }
  }

  function applyDimProfileToRows(options={}){
    if(!Array.isArray(STATE.rows)) return 0;
    const renderNow = options?.render !== false;
    const tagMap = new Map();
    for(const tag of dimProfile?.tags || []){
      if(tag?.id){
        tagMap.set(normId(tag.id), tag);
      }
    }
    const hashTagMap = new Map();
    for(const entry of dimProfile?.itemHashTags || []){
      if(entry && Number.isFinite(entry.hash)){
        hashTagMap.set(Number(entry.hash), entry);
      }
    }
    let changed = 0;
    for(const row of STATE.rows){
      const id = normId(row?.Id);
      if(!rowBaseTags.has(id)){
        const base = typeof row?.Tag === 'string' ? row.Tag : (row?.Tag ?? '');
        rowBaseTags.set(id, base || '');
      }
      const baseTag = rowBaseTags.get(id) || '';
      let nextTag = baseTag;
      const dimTag = tagMap.get(id);
      if(dimTag && typeof dimTag.tag === 'string' && dimTag.tag){
        nextTag = dimTag.tag;
      }else if((!nextTag || nextTag === '') && row?.ItemHash != null){
        const hashEntry = hashTagMap.get(Number(row.ItemHash));
        if(hashEntry && typeof hashEntry.tag === 'string' && hashEntry.tag){
          nextTag = hashEntry.tag;
        }
      }
      if(row.Tag !== nextTag){
        row.Tag = nextTag || '';
        changed++;
      }
    }
    if(changed && renderNow){
      render();
    }
    return changed;
  }

  function initDimIntegration(){
    dimStatusEl = document.getElementById('dimStatus');
    dimLoginBtn = document.getElementById('dimLogin');
    dimRefreshBtn = document.getElementById('dimRefresh');
    dimLogoutBtn = document.getElementById('dimLogout');
    dimApiKeyInput = document.getElementById('dimApiKey');

    if(dimApiKeyInput){
      dimApiKeyInput.value = dimConfig?.apiKey || '';
      dimApiKeyInput.addEventListener('change', (event) => {
        dimConfig.apiKey = (event.target.value || '').trim();
        saveDimConfig();
        updateDimUI();
        if(!dimConfig.apiKey){
          setDimStatus('Add a DIM API key to enable DIM Sync.', 'info');
        }
      });
    }

    if(dimLoginBtn){
      dimLoginBtn.addEventListener('click', () => {
        syncDimProfile({ reason: 'manual' });
      });
    }

    if(dimRefreshBtn){
      dimRefreshBtn.addEventListener('click', () => {
        syncDimProfile({ reason: 'manual' });
      });
    }

    if(dimLogoutBtn){
      dimLogoutBtn.addEventListener('click', () => {
        clearDimTokens(true);
      });
    }

    if(dimProfile && (Array.isArray(dimProfile.tags) || Array.isArray(dimProfile.itemHashTags))){
      const tagCount = Array.isArray(dimProfile.tags) ? dimProfile.tags.length : 0;
      const hashTagCount = Array.isArray(dimProfile.itemHashTags) ? dimProfile.itemHashTags.length : 0;
      if(tagCount || hashTagCount){
        setDimStatus(`Loaded ${tagCount} DIM tag${tagCount === 1 ? '' : 's'} from last sync.`, 'info');
      }else if(!dimConfig?.apiKey){
        setDimStatus('Add a DIM API key to enable DIM Sync.', 'info');
      }
    }else if(!dimConfig?.apiKey){
      setDimStatus('Add a DIM API key to enable DIM Sync.', 'info');
    }

    updateDimUI();

    if(dimTokens?.accessToken){
      syncDimProfile({ reason: 'auto', silent: true });
    }
  }

  function updateBungieUI(){
    const hasConfig = Boolean((bungieConfig?.apiKey || '').trim() && (bungieConfig?.clientId || '').trim());
    const hasRefresh = Boolean(bungieTokens?.refreshToken);
    const refreshValid = hasRefresh && Date.now() < ((bungieTokens.refreshTokenExpires || 0) - 60000);
    const signedIn = hasRefresh && refreshValid;
    if(bungieLoginBtn) bungieLoginBtn.disabled = bungieIsFetching || !hasConfig;
    if(bungieRefreshBtn) bungieRefreshBtn.disabled = bungieIsFetching || !signedIn || !hasConfig;
    if(bungieLogoutBtn) bungieLogoutBtn.disabled = bungieIsFetching || !hasRefresh;
    if(bungieMembershipWrap){
      bungieMembershipWrap.style.display = bungieMemberships.length ? 'block' : 'none';
    }
    const uiSignature = JSON.stringify({ hasConfig, hasRefresh, refreshValid, signedIn, bungieIsFetching });
    if(uiSignature !== debugState.lastUiStateSignature){
      debugState.lastUiStateSignature = uiSignature;
      logDebug('updateBungieUI', { hasConfig, hasRefresh, refreshValid, signedIn, bungieIsFetching });
    }
    updateDebugSnapshot();
  }

  function renderMembershipOptions(){
    if(!bungieMembershipSelect || !bungieMembershipWrap){
      return;
    }
    bungieMembershipSelect.innerHTML = '';
    if(!bungieMemberships.length){
      bungieMembershipWrap.style.display = 'none';
      return;
    }
    bungieMembershipWrap.style.display = 'block';
    let hasSelection = false;
    for(const mem of bungieMemberships){
      const opt = document.createElement('option');
      opt.value = `${mem.membershipType}:${mem.membershipId}`;
      opt.textContent = mem.label;
      if(String(bungieConfig?.membershipType) === String(mem.membershipType) && String(bungieConfig?.membershipId) === String(mem.membershipId)){
        opt.selected = true;
        hasSelection = true;
      }
      bungieMembershipSelect.appendChild(opt);
    }
    if(!hasSelection && bungieMembershipSelect.options.length > 0){
      bungieMembershipSelect.selectedIndex = 0;
      const [type,id] = bungieMembershipSelect.value.split(':');
      bungieConfig.membershipType = Number(type);
      bungieConfig.membershipId = id;
      saveBungieConfig();
    }
    logDebug('renderMembershipOptions', {
      totalMemberships: bungieMemberships.length,
      selectedMembership: bungieMembershipSelect?.value || null
    });
    updateBungieUI();
  }

  function formatMembershipLabel(mem){
    const code = mem?.bungieGlobalDisplayNameCode != null ? String(mem.bungieGlobalDisplayNameCode).padStart(4,'0') : '';
    const baseName = mem?.bungieGlobalDisplayName ? `${mem.bungieGlobalDisplayName}${code ? '#' + code : ''}` : (mem?.displayName || mem?.lastSeenDisplayName || 'Guardian');
    const platform = MEMBERSHIP_TYPE_NAMES[mem?.membershipType] || `Type ${mem?.membershipType}`;
    return `${baseName} â€¢ ${platform}`;
  }

  function getSelectedMembership(){
    if(!bungieMemberships.length) return null;
    const found = bungieMemberships.find(mem => String(mem.membershipType) === String(bungieConfig?.membershipType) && String(mem.membershipId) === String(bungieConfig?.membershipId));
    if(found) return found;
    const fallback = bungieMemberships[0];
    if(fallback){
      bungieConfig.membershipType = fallback.membershipType;
      bungieConfig.membershipId = fallback.membershipId;
      saveBungieConfig();
      renderMembershipOptions();
    }
    return fallback || null;
  }

  function setBungieStatus(message, type='info'){
    const normalizedMessage = message || '';
    const changed = debugState.lastStatus.message !== normalizedMessage || debugState.lastStatus.type !== type;
    debugState.lastStatus = { message: normalizedMessage, type };
    if(changed){
      logDebug('status', { message: normalizedMessage, type });
    }
    updateDebugSnapshot();
    if(!bungieStatusEl) return;
    bungieStatusEl.textContent = normalizedMessage;
    bungieStatusEl.classList.remove('status-ok','status-error','status-loading');
    const isInfo = !normalizedMessage || type === 'info';
    bungieStatusEl.classList.toggle('muted', isInfo);
    if(type === 'ok') bungieStatusEl.classList.add('status-ok');
    else if(type === 'error') bungieStatusEl.classList.add('status-error');
    else if(type === 'loading') bungieStatusEl.classList.add('status-loading');
  }

  const PKCE_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';

  function randomString(length){
    const array = new Uint8Array(length);
    if(window.crypto?.getRandomValues){
      window.crypto.getRandomValues(array);
    }else{
      for(let i=0;i<length;i++){ array[i] = Math.floor(Math.random()*PKCE_CHARSET.length); }
    }
    let out = '';
    for(let i=0;i<length;i++){
      out += PKCE_CHARSET[array[i] % PKCE_CHARSET.length];
    }
    return out;
  }

  function base64UrlEncode(buffer){
    let binary = '';
    const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    for(let i=0;i<bytes.byteLength;i++){
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }

  async function createCodeChallenge(verifier){
    if(!window.crypto?.subtle){
      throw new Error('Browser crypto API is not available for PKCE.');
    }
    const data = new TextEncoder().encode(verifier);
    const digest = await window.crypto.subtle.digest('SHA-256', data);
    return base64UrlEncode(new Uint8Array(digest));
  }

  async function startBungieAuth(){
    try{
      ensureBungieConfigDefaults();
      logDebug('startBungieAuth', {
        hasClientId: Boolean(bungieConfig?.clientId),
        hasApiKey: Boolean(bungieConfig?.apiKey)
      });
      if(!bungieConfig?.clientId || !bungieConfig?.apiKey){
        setBungieStatus('Bungie credentials are missing. Refresh and try again.', 'error');
        return;
      }
      saveBungieConfig();
      const verifier = randomString(64);
      const challenge = await createCodeChallenge(verifier);
      const state = randomString(32);
      const returnUrl = window.location.href.split('#')[0];
      const redirectUri = BUNGIE_REDIRECT_URI || returnUrl;
      sessionStorage.setItem(BUNGIE_VERIFIER_STORAGE, verifier);
      sessionStorage.setItem(BUNGIE_STATE_STORAGE, state);
      sessionStorage.setItem(BUNGIE_RETURN_STORAGE, returnUrl);
      const url = new URL(BUNGIE_OAUTH_URL);
      url.searchParams.set('client_id', bungieConfig.clientId);
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('state', state);
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('code_challenge_method', 'S256');
      if(redirectUri){
        url.searchParams.set('redirect_uri', redirectUri);
      }
      setBungieStatus('Redirecting to Bungie for sign-inâ€¦', 'loading');
      logDebug('bungieAuthRedirect', {
        redirectUri,
        returnUrl,
        state,
        hasVerifier: Boolean(verifier)
      });
      window.location.href = url.toString();
    }catch(err){
      console.error(err);
      logDebug('startBungieAuth error', { error: err?.message || err });
      setBungieStatus('Unable to start Bungie sign-in: ' + (err?.message || err), 'error');
    }
  }

  function cleanOAuthParams(){
    const storedReturn = sessionStorage.getItem(BUNGIE_RETURN_STORAGE);
    if(storedReturn){
      window.history.replaceState({}, document.title, storedReturn);
      return;
    }
    try{
      const current = new URL(window.location.href);
      current.searchParams.delete('code');
      current.searchParams.delete('state');
      current.searchParams.delete('error');
      current.searchParams.delete('error_description');
      window.history.replaceState({}, document.title, current.toString());
    }catch(err){
      console.warn('Failed to clean OAuth params', err);
    }
  }

  async function handleOAuthRedirect(){
    const params = new URLSearchParams(window.location.search);
    const error = params.get('error');
    logDebug('handleOAuthRedirect', {
      hasCode: params.has('code'),
      hasError: Boolean(error)
    });
    if(error){
      cleanOAuthParams();
      setBungieStatus(`Authorization failed: ${error}`, 'error');
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
      logDebug('handleOAuthRedirect error', { error });
      return;
    }
    const code = params.get('code');
    if(!code) return;
    const state = params.get('state');
    const storedState = sessionStorage.getItem(BUNGIE_STATE_STORAGE);
    const verifier = sessionStorage.getItem(BUNGIE_VERIFIER_STORAGE);
    if(!storedState || !verifier || storedState !== state){
      cleanOAuthParams();
      setBungieStatus('Authorization state mismatch. Please try signing in again.', 'error');
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
      logDebug('handleOAuthRedirect stateMismatch', { storedState, state, hasVerifier: Boolean(verifier) });
      return;
    }
    try{
      setBungieStatus('Completing Bungie authorizationâ€¦', 'loading');
      logDebug('exchangeAuthCode start', { hasCode: Boolean(code), hasVerifier: Boolean(verifier) });
      const redirectUri = sessionStorage.getItem(BUNGIE_RETURN_STORAGE) || BUNGIE_REDIRECT_URI;
      const loaded = await exchangeAuthCode(code, verifier, redirectUri);
      if(!loaded){
        const hasError = bungieStatusEl?.classList?.contains('status-error');
        if(!hasError){
          setBungieStatus('Authorization complete. Use Refresh armor to pull your gear.', 'ok');
        }
        logDebug('exchangeAuthCode completed', { autoLoaded: Boolean(loaded) });
      }
    }catch(err){
      console.error(err);
      logDebug('handleOAuthRedirect exception', { error: err?.message || err });
      setBungieStatus('Failed to complete authorization: ' + (err?.message || err), 'error');
    }finally{
      cleanOAuthParams();
      sessionStorage.removeItem(BUNGIE_VERIFIER_STORAGE);
      sessionStorage.removeItem(BUNGIE_STATE_STORAGE);
      sessionStorage.removeItem(BUNGIE_RETURN_STORAGE);
    }
  }

  async function exchangeAuthCode(code, verifier, redirectUri){
    ensureBungieConfigDefaults();
    const body = new URLSearchParams();
    body.set('client_id', bungieConfig?.clientId || '');
    body.set('grant_type', 'authorization_code');
    body.set('code', code);
    body.set('code_verifier', verifier);
    if(redirectUri){
      body.set('redirect_uri', redirectUri);
    }
    const headers = new Headers({
      'Content-Type':'application/x-www-form-urlencoded',
      'Accept':'application/json'
    });
    logDebug('exchangeAuthCode fetch', {
      hasCode: Boolean(code),
      hasVerifier: Boolean(verifier),
      redirectUri
    });
    let resp;
    try{
      resp = await fetch(BUNGIE_TOKEN_URL, {
        method:'POST',
        headers,
        body
      });
    }catch(err){
      logDebug('exchangeAuthCode networkError', { error: err?.message || err });
      throw new Error(formatBungieNetworkError(err));
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok){
      const rawMsg = data?.error_description || data?.Message || `HTTP ${resp.status}`;
      const msg = rawMsg === 'OriginHeaderDoesNotMatchKey'
        ? 'OriginHeaderDoesNotMatchKey: Add https://erebusares.github.io to the Origin Header whitelist for your Bungie application and redeploy.'
        : rawMsg;
      logDebug('exchangeAuthCode failed', { status: resp.status, message: msg });
      throw new Error(msg);
    }
    if(!data?.access_token){
      logDebug('exchangeAuthCode missingAccessToken', { hasAccessToken: Boolean(data?.access_token) });
      throw new Error('Missing access token in Bungie response.');
    }
    bungieTokens = {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      accessTokenExpires: Date.now() + (Number(data.expires_in || 0) * 1000),
      refreshTokenExpires: Date.now() + (Number(data.refresh_expires_in || 0) * 1000),
      tokenType: data.token_type || 'Bearer',
      membershipId: data.membership_id || bungieConfig?.membershipId || null,
      membershipType: data.membership_type != null ? data.membership_type : bungieConfig?.membershipType || null
    };
    saveBungieTokens();
    updateBungieUI();
    logDebug('exchangeAuthCode success', {
      membershipId: bungieTokens.membershipId,
      membershipType: bungieTokens.membershipType,
      accessExpiresIn: Number(data.expires_in || 0),
      refreshExpiresIn: Number(data.refresh_expires_in || 0)
    });
    const membership = await fetchMemberships();
    if(membership){
      const loaded = await loadArmorFromBungie({ reason: 'auto' });
      return loaded;
    }
    return false;
  }

  async function ensureAccessToken(){
    const hasAccess = Boolean(bungieTokens?.accessToken);
    const hasRefresh = Boolean(bungieTokens?.refreshToken);
    const now = Date.now();
    const accessExpires = Number(bungieTokens?.accessTokenExpires || 0);
    const refreshExpires = Number(bungieTokens?.refreshTokenExpires || 0);

    // If we have a usable access token, return it even if no refresh token exists yet.
    if(hasAccess && (!accessExpires || now < (accessExpires - 60000))){
      logDebug('ensureAccessToken cached', {
        accessTokenExpiresInMs: accessExpires ? accessExpires - now : null
      });
      return bungieTokens.accessToken;
    }

    if(!hasRefresh){
      logDebug('ensureAccessToken missingRefresh', {});
      throw new Error('No Bungie session available. Sign in first.');
    }

    if(refreshExpires && now >= (refreshExpires - 60000)){
      logDebug('ensureAccessToken refreshExpired', {
        refreshExpiresInMs: refreshExpires - now
      });
      clearBungieTokens(false);
      throw new Error('Bungie session expired. Please sign in again.');
    }

    logDebug('ensureAccessToken refreshing', {
      refreshExpiresInMs: refreshExpires ? refreshExpires - now : null
    });
    await refreshAccessToken();
    return bungieTokens.accessToken;
  }

  async function refreshAccessToken(){
    ensureBungieConfigDefaults();
    const body = new URLSearchParams();
    body.set('client_id', bungieConfig?.clientId || '');
    body.set('grant_type', 'refresh_token');
    body.set('refresh_token', bungieTokens?.refreshToken || '');
    const headers = new Headers({
      'Content-Type':'application/x-www-form-urlencoded',
      'Accept':'application/json'
    });
    logDebug('refreshAccessToken fetch', {
      hasRefreshToken: Boolean(bungieTokens?.refreshToken)
    });
    let resp;
    try{
      resp = await fetch(BUNGIE_TOKEN_URL, {
        method:'POST',
        headers,
        body
      });
    }catch(err){
      logDebug('refreshAccessToken networkError', { error: err?.message || err });
      throw new Error(formatBungieNetworkError(err));
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok || !data?.access_token){
      const rawMsg = data?.error_description || data?.Message || `HTTP ${resp.status}`;
      const msg = rawMsg === 'OriginHeaderDoesNotMatchKey'
        ? 'OriginHeaderDoesNotMatchKey: Add https://erebusares.github.io to the Origin Header whitelist for your Bungie application and redeploy.'
        : rawMsg;
      clearBungieTokens(false);
      logDebug('refreshAccessToken failed', { status: resp.status, message: msg });
      throw new Error(msg);
    }
    bungieTokens.accessToken = data.access_token;
    bungieTokens.accessTokenExpires = Date.now() + (Number(data.expires_in || 0) * 1000);
    if(data.refresh_token){
      bungieTokens.refreshToken = data.refresh_token;
    }
    if(data.refresh_expires_in){
      bungieTokens.refreshTokenExpires = Date.now() + Number(data.refresh_expires_in) * 1000;
    }
    if(data.token_type){
      bungieTokens.tokenType = data.token_type;
    }
    if(data.membership_id){
      bungieTokens.membershipId = data.membership_id;
    }
    if(data.membership_type != null){
      bungieTokens.membershipType = data.membership_type;
    }
    saveBungieTokens();
    logDebug('refreshAccessToken success', {
      accessExpiresIn: Number(data.expires_in || 0),
      refreshExpiresIn: Number(data.refresh_expires_in || 0)
    });
  }

  function formatBungieNetworkError(err){
    const rawMessage = (err?.message || '').trim();
    const normalized = rawMessage || 'Network request failed.';
    const lowered = normalized.toLowerCase();
    if(lowered.includes('failed to fetch') || lowered.includes('networkerror') || lowered.includes('load failed')){
      let currentOrigin = '';
      try{
        currentOrigin = window.location?.origin || '';
      }catch(_){
        currentOrigin = '';
      }
      const isOpaque = !currentOrigin || currentOrigin === 'null';
      if(isOpaque){
        return `Network error contacting Bungie. Serve this page from ${BUNGIE_ALLOWED_ORIGIN} or another web server and add that origin to your Bungie application's Origin Header whitelist before trying again.`;
      }
      if(currentOrigin !== BUNGIE_ALLOWED_ORIGIN){
        return `Network error contacting Bungie from ${currentOrigin}. Add this origin (without a trailing slash) to the Bungie application's Origin Header whitelist alongside ${BUNGIE_ALLOWED_ORIGIN}, publish the change, and reload before trying again.`;
      }
      return `Network error contacting Bungie from ${currentOrigin}. Confirm this origin appears in the Bungie application's Origin Header whitelist and try again in a few moments.`;
    }
    return normalized;
  }

  function formatDimNetworkError(err){
    const rawMessage = (err?.message || '').trim();
    const normalized = rawMessage || 'Network request failed.';
    const lowered = normalized.toLowerCase();
    if(lowered.includes('failed to fetch') || lowered.includes('networkerror') || lowered.includes('load failed')){
      return 'Network error contacting the DIM Sync API. Confirm your connection and that api.destinyitemmanager.com is reachable, then try again.';
    }
    return normalized;
  }

  function formatBungieError(data, status){
    const rawMessage = data?.Message || data?.message || data?.error_description || data?.error || `HTTP ${status}`;
    const errorStatus = data?.ErrorStatus || data?.Error || data?.error;
    const normalized = (rawMessage || '').trim();
    const originMismatch = normalized === 'Origin header does not match the provided API key.'
      || normalized === 'OriginHeaderDoesNotMatchKey'
      || errorStatus === 'OriginHeaderDoesNotMatchKey';
    if(originMismatch){
      let currentOrigin = '';
      try{
        currentOrigin = window.location?.origin || '';
      }catch(_){
        currentOrigin = '';
      }
      const isOpaqueOrigin = !currentOrigin || currentOrigin === 'null';
      if(isOpaqueOrigin){
        return `OriginHeaderDoesNotMatchKey: Bungie rejected the request because local files do not set an Origin header. Serve this page from ${BUNGIE_ALLOWED_ORIGIN} or run it through a local web server (for example, http://localhost:4173) and add that origin to the Bungie application's Origin Header whitelist before retrying.`;
      }
      if(currentOrigin !== BUNGIE_ALLOWED_ORIGIN){
        return `OriginHeaderDoesNotMatchKey: Bungie rejected the request because ${currentOrigin} is not on the API key's Origin Header whitelist. Add both ${currentOrigin} and ${BUNGIE_ALLOWED_ORIGIN} (no trailing slashes) in the Bungie developer portal, publish the change, and reload.`;
      }
      return `OriginHeaderDoesNotMatchKey: Bungie rejected the request even though the page is hosted on ${BUNGIE_ALLOWED_ORIGIN}. Double-check the application's Origin Header whitelist in the Bungie developer portal, publish the update, wait a few minutes for it to propagate, and reload before trying again.`;
    }
    return normalized || `HTTP ${status}`;
  }

  async function bungieApiRequest(path, options={}, retry=true){
    ensureBungieConfigDefaults();
    const cfg = bungieConfig || {};
    if(!cfg.apiKey){
      throw new Error('Bungie API key is missing.');
    }
    await ensureAccessToken();
    const headers = new Headers(options.headers || {});
    headers.set('X-API-Key', cfg.apiKey);
    headers.set('Authorization', `${bungieTokens?.tokenType || 'Bearer'} ${bungieTokens?.accessToken || ''}`);
    headers.set('Accept', 'application/json');
    const startedAt = Date.now();
    logDebug('bungieApiRequest', {
      path,
      method: options.method || 'GET',
      retry
    });
    let resp;
    try{
      resp = await fetch(`${BUNGIE_API_ROOT}${path}`, {
        method: options.method || 'GET',
        ...options,
        headers
      });
    }catch(err){
      logDebug('bungieApiRequest networkError', { path, error: err?.message || err });
      throw new Error(formatBungieNetworkError(err));
    }
    if(resp.status === 401 && retry){
      logDebug('bungieApiRequest unauthorized', { path });
      await refreshAccessToken();
      return bungieApiRequest(path, options, false);
    }
    const data = await resp.json().catch(()=>null);
    if(!resp.ok){
      const message = formatBungieError(data, resp.status);
      logDebug('bungieApiRequest failed', {
        path,
        status: resp.status,
        message
      });
      throw new Error(message);
    }
    if(data?.ErrorCode && data.ErrorCode !== 1){
      const message = formatBungieError(data, resp.status);
      logDebug('bungieApiRequest errorCode', {
        path,
        status: resp.status,
        errorCode: data.ErrorCode,
        message
      });
      throw new Error(message);
    }
    logDebug('bungieApiRequest success', {
      path,
      status: resp.status,
      elapsedMs: Date.now() - startedAt
    });
    return data?.Response;
  }

  function hashKey(hash){
    const num = Number(hash);
    if(Number.isNaN(num)) return String(hash);
    return String(num >>> 0);
  }

  async function getManifestIndex(){
    if(!manifestIndexPromise){
      manifestIndexPromise = bungieApiRequest('/Destiny2/Manifest/').catch(err => {
        manifestIndexPromise = null;
        throw err;
      });
    }
    const manifest = await manifestIndexPromise;
    if(!manifest){
      throw new Error('Failed to load Destiny manifest index.');
    }
    return manifest;
  }

  function resolveManifestComponentPath(manifest, componentName){
    const localePaths = manifest?.jsonWorldComponentContentPaths || {};
    const preferredLocales = [];
    const configuredLocale = String(bungieConfig?.manifestLocale || '').trim().toLowerCase();
    if(configuredLocale && localePaths[configuredLocale]){
      preferredLocales.push(configuredLocale);
    }
    const browserLocale = (typeof navigator !== 'undefined' && navigator?.language)
      ? navigator.language.toLowerCase()
      : '';
    if(browserLocale){
      if(localePaths[browserLocale] && !preferredLocales.includes(browserLocale)){
        preferredLocales.push(browserLocale);
      }
      const shortLocale = browserLocale.split('-')[0];
      if(localePaths[shortLocale] && !preferredLocales.includes(shortLocale)){
        preferredLocales.push(shortLocale);
      }
    }
    if(localePaths.en && !preferredLocales.includes('en')){
      preferredLocales.push('en');
    }
    for(const locale of Object.keys(localePaths)){
      if(!preferredLocales.includes(locale)){
        preferredLocales.push(locale);
      }
    }
    for(const locale of preferredLocales){
      const locPaths = localePaths[locale];
      if(locPaths && locPaths[componentName]){
        return { path: locPaths[componentName], locale };
      }
    }
    return { path: null, locale: null };
  }

  async function loadManifestComponent(componentName){
    if(manifestComponentCache.has(componentName)){
      return manifestComponentCache.get(componentName);
    }
    if(manifestComponentPromises.has(componentName)){
      return manifestComponentPromises.get(componentName);
    }
    const promise = (async () => {
      const manifest = await getManifestIndex();
      const { path, locale } = resolveManifestComponentPath(manifest, componentName);
      if(!path){
        throw new Error(`Manifest component path missing for ${componentName}`);
      }
      const url = `https://www.bungie.net${path}`;
      const response = await fetch(url);
      if(!response.ok){
        throw new Error(`Failed to load manifest component ${componentName}: ${response.status}`);
      }
      const json = await response.json();
      manifestComponentCache.set(componentName, json);
      logDebug('manifest component loaded', {
        component: componentName,
        locale,
        entryCount: json && typeof json === 'object' ? Object.keys(json).length : null
      });
      return json;
    })();
    manifestComponentPromises.set(componentName, promise);
    try{
      const data = await promise;
      manifestComponentPromises.delete(componentName);
      return data;
    }catch(err){
      manifestComponentPromises.delete(componentName);
      throw err;
    }
  }

  async function getInventoryItemDefinition(hash){
    const key = hashKey(hash);
    if(manifestCache.inventoryItem.has(key)){
      return manifestCache.inventoryItem.get(key);
    }
    const component = await loadManifestComponent(MANIFEST_COMPONENT_INVENTORY_ITEM);
    const def = component?.[key] || null;
    if(def){
      manifestCache.inventoryItem.set(key, def);
    }else{
      logDebug('inventory definition missing', { hash: key });
    }
    return def;
  }

  async function getSocketTypeDefinition(hash){
    const key = hashKey(hash);
    if(manifestCache.socketType.has(key)){
      return manifestCache.socketType.get(key);
    }
    const component = await loadManifestComponent(MANIFEST_COMPONENT_SOCKET_TYPE);
    const def = component?.[key] || null;
    if(def){
      manifestCache.socketType.set(key, def);
    }else{
      logDebug('socket type definition missing', { hash: key });
    }
    return def;
  }

  async function prefetchInventoryItemDefinitions(hashes, concurrency = 10){
    if(!Array.isArray(hashes) || hashes.length === 0){
      return;
    }
    logDebug('prefetchInventoryItemDefinitions start', {
      requested: hashes.length,
      concurrency
    });
    const queue = [];
    const seen = new Set();
    for(const rawHash of hashes){
      const key = hashKey(rawHash);
      if(!key || seen.has(key)){
        continue;
      }
      seen.add(key);
      if(manifestCache.inventoryItem.has(key)){
        continue;
      }
      queue.push(key);
    }
    const totalQueued = queue.length;
    while(queue.length){
      const batch = queue.splice(0, Math.max(1, concurrency));
      await Promise.all(batch.map(async hash => {
        try{
          await getInventoryItemDefinition(hash);
        }catch(err){
          console.error('Failed to preload manifest definition', hash, err);
          logDebug('prefetchInventoryItemDefinitions error', { hash, error: err?.message || err });
          throw err;
        }
      }));
    }
    logDebug('prefetchInventoryItemDefinitions complete', {
      requested: hashes.length,
      queued: totalQueued
    });
  }

  async function transformProfileToRows(profile){
    const itemsMap = new Map();
    logDebug('transformProfileToRows start', {
      hasProfileInventory: Array.isArray(profile?.profileInventory?.data?.items),
      hasCharacterInventories: Boolean(profile?.characterInventories?.data),
      hasCharacterEquipment: Boolean(profile?.characterEquipment?.data)
    });
    const addItems = (items)=>{
      if(!Array.isArray(items)) return;
      for(const item of items){
        if(!item || !item.itemInstanceId) continue;
        if(itemsMap.has(item.itemInstanceId)) continue;
        itemsMap.set(item.itemInstanceId, item);
      }
    };
    addItems(profile?.profileInventory?.data?.items);
    const charInventories = profile?.characterInventories?.data || {};
    for(const inv of Object.values(charInventories)){
      addItems(inv?.items);
    }
    const charEquipment = profile?.characterEquipment?.data || {};
    for(const equip of Object.values(charEquipment)){
      addItems(equip?.items);
    }
    logDebug('transformProfileToRows itemsCollected', { totalItems: itemsMap.size });
    if(itemsMap.size === 0) return [];
    const instances = profile?.itemComponents?.instances?.data || {};
    const statsByItem = profile?.itemComponents?.stats?.data || {};
    const socketsByItem = profile?.itemComponents?.sockets?.data || {};
    const relevantItems = [];
    for(const [instanceId, item] of itemsMap.entries()){
      const bucketKey = hashKey(item.bucketHash);
      let isArmorCandidate = !!ARMOR_BUCKET_HASH_TO_TYPE[bucketKey];
      if(!isArmorCandidate){
        const statMap = statsByItem?.[instanceId]?.stats;
        if(statMap){
          for(const statHash of Object.keys(statMap)){
            if(STAT_HASH_TO_LABEL[hashKey(statHash)]){
              isArmorCandidate = true;
              break;
            }
          }
        }
      }
      if(!isArmorCandidate){
        const energy = instances?.[instanceId]?.energy;
        if(energy && (Number.isFinite(energy?.energyCapacity) || Number.isFinite(energy?.energyLevel))){
          isArmorCandidate = true;
        }
      }
      if(isArmorCandidate){
        relevantItems.push(item);
      }
    }
    logDebug('transformProfileToRows relevantItems', { count: relevantItems.length });
    if(relevantItems.length === 0) return [];
    const uniqueItemKeys = new Set();
    const uniqueItemHashes = [];
    const plugKeys = new Set();
    const plugHashList = [];
    for(const item of relevantItems){
      const itemKey = hashKey(item.itemHash);
      if(itemKey && !uniqueItemKeys.has(itemKey)){
        uniqueItemKeys.add(itemKey);
        uniqueItemHashes.push(item.itemHash);
      }
      const sockets = socketsByItem?.[item.itemInstanceId]?.sockets;
      if(!Array.isArray(sockets)) continue;
      for(const socket of sockets){
        if(!socket || socket?.plugged?.enabled === false) continue;
        const plugHash = getSocketPlugHash(socket);
        const plugKey = plugHash != null ? hashKey(plugHash) : null;
        if(!plugKey || plugKeys.has(plugKey)) continue;
        plugKeys.add(plugKey);
        plugHashList.push(plugHash);
      }
    }
    logDebug('transformProfileToRows manifestPrefetch', {
      itemDefinitions: uniqueItemHashes.length,
      plugDefinitions: plugHashList.length
    });
    await prefetchInventoryItemDefinitions(uniqueItemHashes.concat(plugHashList));
    const rows = [];
    for(const item of relevantItems){
      const def = await getInventoryItemDefinition(item.itemHash);
      const sockets = socketsByItem?.[item.itemInstanceId]?.sockets || [];
      const row = await buildRowFromDefinition(
        item,
        def,
        instances[item.itemInstanceId],
        statsByItem[item.itemInstanceId]?.stats || {},
        sockets
      );
      if(row) rows.push(row);
    }
    logDebug('transformProfileToRows complete', { rows: rows.length });
    return rows;
  }

  function getSocketPlugHash(socket){
    if(!socket) return null;
    const plugHash = socket?.plugged?.plugItemHash
      ?? socket?.plugged?.plugHash
      ?? socket?.plugHash
      ?? socket?.plugItemHash;
    return plugHash != null ? plugHash : null;
  }

  function toFiniteNumber(value){
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : null;
  }

  function deriveEnergyTierInfo(energy){
    if(!energy){
      return {
        tier: 0,
        source: null,
        upgradeLevel: null,
        level: null,
        capacity: null,
        used: null,
        unused: null
      };
    }
    const level = toFiniteNumber(energy?.energyLevel);
    const capacity = toFiniteNumber(energy?.energyCapacity);
    const usedRaw = toFiniteNumber(energy?.energyUsed);
    const unused = toFiniteNumber(energy?.energyUnused);

    const used = Number.isFinite(usedRaw) ? Math.max(0, Math.min(usedRaw, 10)) : null;
    const usedFromCapacity = (Number.isFinite(capacity) && Number.isFinite(unused))
      ? Math.max(0, Math.min(capacity - unused, 10))
      : null;

    const usedPlusUnused = (used !== null && Number.isFinite(unused))
      ? Math.max(0, used + Math.max(0, Math.min(unused, 10)))
      : null;

    let upgradeLevel = null;
    let source = null;

    const assignIfUnset = (value, valueSource) => {
      if(upgradeLevel !== null) return;
      if(!Number.isFinite(value)) return;
      upgradeLevel = value;
      source = valueSource;
    };

    assignIfUnset(level, 'energyLevel');
    assignIfUnset(usedFromCapacity, 'energyCapacityMinusUnused');
    assignIfUnset(capacity, 'energyCapacity');
    assignIfUnset(usedPlusUnused, 'energyUsedPlusUnused');
    assignIfUnset(used, 'energyUsed');

    if(upgradeLevel !== null){
      upgradeLevel = Math.max(0, Math.min(upgradeLevel, 10));
    }

    let tier = 0;
    if(upgradeLevel !== null){
      tier = Math.ceil(Math.max(0, upgradeLevel) / 2);
      if(tier < 0) tier = 0;
      if(tier > 5) tier = 5;
      if(upgradeLevel > 0 && tier === 0){
        tier = 1;
      }
    }

    return {
      tier,
      source,
      upgradeLevel,
      level,
      capacity,
      used,
      unused
    };
  }

  // Destiny Item Manager removes every socket-provided stat bonus except for intrinsic
  // or frame plugs when it has to derive base stats manually. We mostly rely on Bungie's
  // provided `stat.base` values, but we still need this filter for the few cases where
  // the API omits those base numbers and we have to fall back to subtraction.
  function shouldSubtractPlugFromBaseStats(def, plugStats, socketCategoryHash){
    if(!plugStats || plugStats.size === 0) return false;
    if(Number.isFinite(socketCategoryHash)){
      if(ARMOR_BASE_SOCKET_CATEGORY_HASHES.has(socketCategoryHash)){
        return false;
      }
      if(ARMOR_MOD_SOCKET_CATEGORY_HASHES.has(socketCategoryHash)){
        return true;
      }
    }
    if(!def) return true;
    const plugCategoryHash = Number(def?.plug?.plugCategoryHash);
    if(Number.isFinite(plugCategoryHash)){
      if(ARMOR_INTRINSIC_PLUG_CATEGORY_HASHES.has(plugCategoryHash)){
        return false;
      }
      if(ARMOR_MOD_PLUG_CATEGORY_HASHES.has(plugCategoryHash)){
        return true;
      }
    }
    const plugCat = String(def?.plug?.plugCategoryIdentifier || '').toLowerCase();
    if(plugCat){
      if(plugCat === 'intrinsics' || plugCat.startsWith('intrinsics.')) return false;
      if(plugCat.startsWith('frames')) return false;
      if(plugCat.includes('ornament') || plugCat.includes('cosmetic') || plugCat.includes('spawnfx')) return false;
      if(plugCat.includes('tracker')) return false;
      if(plugCat.includes('armor_mod')) return true;
      if(plugCat.includes('enhancements')) return true;
      if(plugCat.includes('armor_tiering')) return true;
      if(plugCat.includes('tuning')) return true;
    }
    if(isMasterworkStatPlug(def)){
      return true;
    }
    const itemCategories = Array.isArray(def?.itemCategoryHashes) ? def.itemCategoryHashes : [];
    for(const catHash of itemCategories){
      if(ARMOR_MOD_ITEM_CATEGORY_HASHES.has(Number(catHash))){
        return true;
      }
    }
    const typeName = String(def?.itemTypeDisplayName || '').toLowerCase();
    if(typeName.includes('ornament') || typeName.includes('shader') || typeName.includes('projection')) return false;
    if(typeName.includes('mod')) return true;
    const displayName = String(def?.displayProperties?.name || '').toLowerCase();
    if(displayName.includes('ornament') || displayName.includes('shader')) return false;
    if(displayName.includes('mod')) return true;
    // Default to subtracting when a plug adjusts stats so new armor mod categories
    // automatically roll into the subtraction path unless they are explicitly
    // identified as intrinsic/cosmetic sockets above.
    return true;
  }

  function isIntrinsicPlugForBaseStats(def, socketCategoryHash){
    if(Number.isFinite(socketCategoryHash) && ARMOR_BASE_SOCKET_CATEGORY_HASHES.has(socketCategoryHash)){
      return true;
    }
    if(!def) return false;
    const plugCategoryHash = Number(def?.plug?.plugCategoryHash);
    if(Number.isFinite(plugCategoryHash) && ARMOR_INTRINSIC_PLUG_CATEGORY_HASHES.has(plugCategoryHash)){
      return true;
    }
    const plugCat = String(def?.plug?.plugCategoryIdentifier || '').toLowerCase();
    if(plugCat){
      if(plugCat === 'intrinsics' || plugCat.startsWith('intrinsics.')) return true;
      if(plugCat.startsWith('frames')) return true;
    }
    return false;
  }

  function isMasterworkStatPlug(def){
    if(!def) return false;
    const plugCat = String(def?.plug?.plugCategoryIdentifier || '').toLowerCase();
    if(plugCat && plugCat.includes('masterwork')) return true;
    const typeName = String(def?.itemTypeDisplayName || '').toLowerCase();
    if(typeName.includes('masterwork')) return true;
    const displayName = String(def?.displayProperties?.name || '').toLowerCase();
    if(displayName.includes('masterwork')) return true;
    return false;
  }

  function getPlugStatValues(socket, plugDef){
    const values = new Map();
    const addStat = (label, amount, overwriteExisting = false) => {
      if(!label) return;
      const numeric = Number(amount ?? 0);
      if(!Number.isFinite(numeric) || numeric === 0) return;
      if(!values.has(label) || overwriteExisting){
        values.set(label, numeric);
      }else{
        values.set(label, values.get(label) + numeric);
      }
    };

    if(plugDef){
      const invStats = Array.isArray(plugDef?.investmentStats) ? plugDef.investmentStats : [];
      for(const stat of invStats){
        const statKey = hashKey(stat?.statTypeHash);
        const label = STAT_HASH_TO_LABEL[statKey];
        addStat(label, stat?.value, false);
      }
    }

    const plugStats = socket?.plugged?.stats;
    if(plugStats && typeof plugStats === 'object'){
      for(const [hash, entry] of Object.entries(plugStats)){
        const statKey = hashKey(hash);
        const label = STAT_HASH_TO_LABEL[statKey];
        if(!label) continue;
        const raw = typeof entry === 'object' && entry !== null ? entry.value : entry;
        if(values.has(label)){ // avoid double counting identical manifest values
          const numeric = Number(raw ?? 0);
          if(Number.isFinite(numeric) && Math.abs(values.get(label) - numeric) > 0.0001){
            values.set(label, numeric);
          }
          continue;
        }
        addStat(label, raw, true);
      }
    }
    return values;
  }

  async function getStatAdjustmentsFromSockets(sockets, socketDefs, options={}){
    const adjustments = {};
    const masterworkAdjustments = {};
    const baseContributions = {};
    let hasRecognizedStatPlug = false;
    let hasRecognizedMasterworkPlug = false;
    const collectDetails = Boolean(options?.collectDetails);
    const debugDetails = collectDetails ? [] : null;
    if(!Array.isArray(sockets)){
      return {
        adjustments,
        masterworkAdjustments,
        baseContributions,
        hasRecognizedStatPlug,
        hasRecognizedMasterworkPlug,
        details: debugDetails || undefined
      };
    }
    for(let index = 0; index < sockets.length; index++){
      const socket = sockets[index];
      if(!socket) continue;
      const socketDef = Array.isArray(socketDefs) ? socketDefs[index] : null;
      let socketCategoryHash = null;
      const socketTypeHash = socketDef?.socketTypeHash;
      if(socketTypeHash != null){
        try{
          const socketTypeDef = await getSocketTypeDefinition(socketTypeHash);
          const categoryHash = Number(socketTypeDef?.socketCategoryHash);
          if(Number.isFinite(categoryHash)){
            socketCategoryHash = categoryHash;
          }
        }catch(err){
          console.warn('Failed to load socket type definition for stat adjustments', socketTypeHash, err);
        }
      }
      const plugHash = getSocketPlugHash(socket);
      if(plugHash == null) continue;
      const enabledFlags = [
        socket?.plugged?.enabled,
        socket?.plugged?.isEnabled,
        socket?.isEnabled,
        socket?.enabled
      ];
      const explicitFlags = enabledFlags.filter(flag => flag === true || flag === false);
      if(explicitFlags.length > 0 && explicitFlags.every(flag => flag === false)) continue;
      let plugDef = manifestCache.inventoryItem.get(hashKey(plugHash));
      if(!plugDef){
        try{
          plugDef = await getInventoryItemDefinition(plugHash);
        }catch(err){
          console.warn('Failed to load plug definition for stat adjustments', plugHash, err);
          plugDef = undefined;
        }
      }
      const plugStats = getPlugStatValues(socket, plugDef);
      if(plugStats.size === 0) continue;
      const treatAsIntrinsic = isIntrinsicPlugForBaseStats(plugDef, socketCategoryHash);
      let subtract = !treatAsIntrinsic;
      if(subtract){
        const heuristic = shouldSubtractPlugFromBaseStats(plugDef, plugStats, socketCategoryHash);
        if(heuristic === false){
          subtract = false;
        }else if(heuristic === true){
          subtract = true;
        }
      }
      const isMasterwork = isMasterworkStatPlug(plugDef);
      if(subtract){
        hasRecognizedStatPlug = true;
        if(isMasterwork){
          hasRecognizedMasterworkPlug = true;
        }
        for(const [label, value] of plugStats.entries()){
          adjustments[label] = (adjustments[label] || 0) + value;
          if(isMasterwork){
            masterworkAdjustments[label] = (masterworkAdjustments[label] || 0) + value;
          }
        }
      }else if(treatAsIntrinsic){
        for(const [label, value] of plugStats.entries()){
          baseContributions[label] = (baseContributions[label] || 0) + value;
        }
      }
      if(debugDetails){
        const statsObject = {};
        for(const [label, value] of plugStats.entries()){
          statsObject[label] = value;
        }
        debugDetails.push({
          plugHash: plugHash != null ? hashKey(plugHash) : null,
          plugName: plugDef?.displayProperties?.name || null,
          socketCategoryHash: socketCategoryHash != null ? Number(socketCategoryHash) : null,
          plugCategoryIdentifier: plugDef?.plug?.plugCategoryIdentifier || null,
          subtract,
          intrinsic: treatAsIntrinsic,
          isMasterwork,
          stats: statsObject,
          enabledFlags: explicitFlags
        });
      }
    }
    return {
      adjustments,
      masterworkAdjustments,
      baseContributions,
      hasRecognizedStatPlug,
      hasRecognizedMasterworkPlug,
      details: debugDetails || undefined
    };
  }

  async function buildRowFromDefinition(item, def, instance, stats, sockets){
    if(!def || !def.inventory) return null;
    if(def.itemType !== 2) return null;
    if(def.classType != null && def.classType > 2 && def.classType !== 3 && def.classType !== 4) return null;
    const bucketKey = hashKey(def.inventory.bucketTypeHash);
    if(!ARMOR_BUCKET_HASH_TO_TYPE[bucketKey]) return null;
    const className = CLASS_BY_TYPE[def.classType] || 'Any';
    const isClassItem = bucketKey === String(1585787867);
    const typeName = isClassItem
      ? (classItemByClass[className] || def.itemTypeDisplayName || 'Class Item')
      : (def.itemTypeDisplayName || ARMOR_BUCKET_HASH_TO_TYPE[bucketKey] || 'Armor');
    const energy = instance?.energy;
    const energyInfo = deriveEnergyTierInfo(energy);
    const energyTierValue = Number.isFinite(energyInfo?.tier) ? energyInfo.tier : null;
    const usedEnergy = Number.isFinite(energyInfo?.used) ? energyInfo.used : null;
    const upgradeLevel = Number.isFinite(energyInfo?.upgradeLevel) ? energyInfo.upgradeLevel : null;
    const capacityLevel = Number.isFinite(energyInfo?.capacity) ? energyInfo.capacity : null;
    const currentEnergy = upgradeLevel ?? capacityLevel ?? usedEnergy ?? null;
    const tierEnergySource = energyInfo?.source || null;
    const row = {
      Id: normId(item.itemInstanceId || item.itemHash),
      Name: def?.displayProperties?.name || 'Unknown Item',
      Type: typeName,
      Equippable: className === 'Unknown' ? 'Any' : className,
      Rarity: def?.inventory?.tierTypeName || '',
      Tag: '',
      Power: instance?.primaryStat?.value ?? '',
      Tier: 0,
      'Total (Base)': 0,
      ItemHash: item?.itemHash ?? null
    };
    const socketDefs = Array.isArray(def?.sockets?.socketEntries) ? def.sockets.socketEntries : [];
    const collectDebug = debugState.armorSamples.length < ARMOR_DEBUG_SAMPLE_LIMIT;
    const socketDetails = await getStatAdjustmentsFromSockets(sockets, socketDefs, { collectDetails: collectDebug });
    const hasRecognizedMasterworkPlug = Boolean(socketDetails?.hasRecognizedMasterworkPlug);
    const hasRecognizedStatPlug = Boolean(socketDetails?.hasRecognizedStatPlug);
    const statDebug = collectDebug ? {} : null;
    const itemStateValue = Number(instance?.state);
    const isMasterworkedByState = Number.isFinite(itemStateValue) && (itemStateValue & DESTINY_ITEM_STATE_MASTERWORK) === DESTINY_ITEM_STATE_MASTERWORK;
    const isMasterworked = isMasterworkedByState
      || (Number.isFinite(capacityLevel) && capacityLevel >= 10)
      || (Number.isFinite(upgradeLevel) && upgradeLevel >= 10);
    for(const [hash,label] of Object.entries(STAT_HASH_TO_LABEL)){
      const stat = stats?.[hash];
      const value = Number(stat?.value);
      const numericValue = Number.isFinite(value) ? value : null;
      const totalAdjustmentRaw = Number(socketDetails?.adjustments?.[label]);
      const rawTotalAdjustment = Number.isFinite(totalAdjustmentRaw) ? totalAdjustmentRaw : 0;
      let totalAdjustment = rawTotalAdjustment;
      const masterworkContributionRaw = Number(socketDetails?.masterworkAdjustments?.[label]);
      let recognizedMasterworkBonus = 0;
      if(Number.isFinite(masterworkContributionRaw)){
        recognizedMasterworkBonus = Math.max(0, Math.min(masterworkContributionRaw, 2));
        totalAdjustment = totalAdjustment - masterworkContributionRaw + recognizedMasterworkBonus;
      }
      const fallbackMasterworkBonus = (!recognizedMasterworkBonus && isMasterworked && !hasRecognizedMasterworkPlug) ? 2 : 0;
      const socketBaseRaw = Number(socketDetails?.baseContributions?.[label]);
      const socketBase = Number.isFinite(socketBaseRaw) ? socketBaseRaw : null;
      const recognizedAdjustment = hasRecognizedStatPlug ? Math.max(0, totalAdjustment) : 0;
      const fallbackMasterworkToSubtract = (!recognizedMasterworkBonus && fallbackMasterworkBonus) ? fallbackMasterworkBonus : 0;
      const adjustmentToSubtract = recognizedAdjustment + fallbackMasterworkToSubtract;

      const apiBase = Number(stat?.base);
      const apiInvestment = Number(stat?.investmentValue);
      let manualBase = null;
      if(Number.isFinite(numericValue) && adjustmentToSubtract > 0){
        const candidate = numericValue - adjustmentToSubtract;
        if(Number.isFinite(candidate)){
          manualBase = Math.max(0, candidate);
        }
      }

      let baseValue = null;
      let baseSource = 'fallback-zero';

      if(Number.isFinite(apiBase)){
        baseValue = apiBase;
        baseSource = 'apiBase';
      }else if(Number.isFinite(apiInvestment)){
        baseValue = apiInvestment;
        baseSource = 'apiInvestment';
      }

      if(Number.isFinite(manualBase)){
        baseValue = manualBase;
        baseSource = 'derivedAdjustments';
      }else if(baseValue === null && Number.isFinite(socketBase)){
        baseValue = socketBase;
        baseSource = 'socketIntrinsic';
      }

      if(baseValue === null){
        if(Number.isFinite(numericValue)){
          baseValue = numericValue;
          baseSource = 'current';
        }else{
          baseValue = 0;
          baseSource = 'fallback-zero';
        }
      }

      if(Number.isFinite(numericValue)){
        if(adjustmentToSubtract > 0){
          baseValue = Math.min(baseValue, numericValue);
        }
      }

      const roundedBase = Math.max(0, Math.round(baseValue));
      row[label] = roundedBase;

      if(statDebug){
        statDebug[label] = {
          current: Number.isFinite(numericValue) ? numericValue : null,
          socketBase,
          manualBase: Number.isFinite(manualBase) ? manualBase : null,
          apiBase: Number.isFinite(apiBase) ? apiBase : null,
          apiInvestment: Number.isFinite(apiInvestment) ? apiInvestment : null,
          rawTotalAdjustment: Number.isFinite(rawTotalAdjustment) ? rawTotalAdjustment : null,
          totalAdjustment: recognizedAdjustment,
          adjustmentToSubtract: Number.isFinite(adjustmentToSubtract) ? adjustmentToSubtract : null,
          recognizedMasterworkBonus,
          fallbackMasterworkBonus,
          fallbackMasterworkApplied: fallbackMasterworkToSubtract,
          baseSource,
          computedBase: roundedBase
        };
      }
    }
    let totalBase = 0;
    for(const label of Object.values(STAT_HASH_TO_LABEL)){
      const value = Number(row[label]);
      if(Number.isFinite(value)){
        totalBase += value;
      }
    }
    row['Total (Base)'] = totalBase;
    const statTier = Math.max(0, Math.floor(totalBase / 10));
    if(Number.isFinite(energyTierValue)){
      row.Tier = energyTierValue;
    }else{
      row.Tier = statTier;
    }
    if(statDebug){
      const capacityNum = Number.isFinite(energyInfo?.capacity) ? energyInfo.capacity : Number(energy?.energyCapacity);
      const usedNum = Number.isFinite(energyInfo?.used) ? energyInfo.used : Number(energy?.energyUsed);
      const unusedNum = Number.isFinite(energyInfo?.unused) ? energyInfo.unused : Number(energy?.energyUnused);
      const levelNum = Number.isFinite(energyInfo?.level) ? energyInfo.level : Number(energy?.energyLevel);
      const sample = {
        name: row.Name,
        type: row.Type,
        tier: statTier,
        totalBase,
        instanceId: item?.itemInstanceId || null,
        itemHash: item?.itemHash || null,
        isMasterworked,
        masterworkFromState: isMasterworkedByState,
        hasRecognizedMasterworkPlug,
        energy: {
          capacity: Number.isFinite(capacityNum) ? capacityNum : null,
          used: Number.isFinite(usedNum) ? usedNum : null,
          unused: Number.isFinite(unusedNum) ? unusedNum : null,
          level: Number.isFinite(levelNum) ? levelNum : null,
          current: Number.isFinite(currentEnergy) ? currentEnergy : null,
          source: tierEnergySource,
          derivedTier: Number.isFinite(energyTierValue) ? energyTierValue : null
        },
        tierSources: {
          stats: statTier,
          energy: Number.isFinite(energyTierValue) ? energyTierValue : null,
          energySource: tierEnergySource
        },
        stats: statDebug,
        adjustments: socketDetails?.adjustments || {},
        masterworkAdjustments: socketDetails?.masterworkAdjustments || {},
        baseContributions: socketDetails?.baseContributions || {},
        sockets: Array.isArray(socketDetails?.details) ? socketDetails.details : []
      };
      recordArmorDebugSample(sample);
      logDebug('armor row sample', sample);
    }
    return row;
  }

  async function fetchMemberships(){
    try{
      logDebug('fetchMemberships start', {});
      const resp = await bungieApiRequest('/User/GetMembershipsForCurrentUser/');
      const memberships = Array.isArray(resp?.destinyMemberships) ? resp.destinyMemberships : [];
      bungieMemberships = memberships.map(m => ({
        membershipId: m.membershipId,
        membershipType: m.membershipType,
        label: formatMembershipLabel(m)
      }));
      let selected = null;
      if(!bungieMemberships.length){
        setBungieStatus('No Destiny 2 memberships were found for this account.', 'error');
      }else{
        selected = bungieMemberships.find(mem => String(mem.membershipType) === String(bungieConfig?.membershipType) && String(mem.membershipId) === String(bungieConfig?.membershipId)) || null;
        if(!selected){
          selected = bungieMemberships[0];
          bungieConfig.membershipType = selected.membershipType;
          bungieConfig.membershipId = selected.membershipId;
          saveBungieConfig();
        }
        if(selected){
          setBungieStatus(`Signed in as ${selected.label}.`, 'ok');
        }else{
          setBungieStatus('Signed in, but no profile is selected.', 'error');
        }
      }
      renderMembershipOptions();
      logDebug('fetchMemberships success', {
        membershipCount: bungieMemberships.length,
        selected: selected?.label || null
      });
      return selected;
    }catch(err){
      console.error(err);
      logDebug('fetchMemberships error', { error: err?.message || err });
      setBungieStatus('Failed to load memberships: ' + (err?.message || err), 'error');
    }
  }

  async function loadArmorFromBungie(options={}){
    const reason = options?.reason || 'manual';
    if(bungieIsFetching){
      logDebug('loadArmorFromBungie skipped', { reason, bungieIsFetching: true });
      return false;
    }
    let success = false;
    try{
      bungieIsFetching = true;
      updateBungieUI();
      logDebug('loadArmorFromBungie start', { reason });
      debugState.armorSamples = [];
      renderDebugArmorSamples();
      const membership = getSelectedMembership();
      if(!membership){
        setBungieStatus('Select a Destiny profile before loading armor.', 'error');
        logDebug('loadArmorFromBungie missingMembership', {});
        return false;
      }
      const startMessage = reason === 'manual' ? 'Refreshing armor from Bungieâ€¦' : 'Loading armor from Bungieâ€¦';
      setBungieStatus(startMessage, 'loading');
      const profile = await bungieApiRequest(`/Destiny2/${membership.membershipType}/Profile/${membership.membershipId}/?components=${BUNGIE_COMPONENTS}`);
      const rows = await transformProfileToRows(profile);
      if(!rows.length){
        setBungieStatus('No armor items were found for this profile.', 'error');
        logDebug('loadArmorFromBungie empty', { reason });
        return false;
      }
      resetBaseTags(rows);
      STATE.rows = rows;
      applyDimProfileToRows({ render: false });
      saveRows();
      render();
      setUploadHint('Loaded via Bungie API');
      const successMessage = reason === 'manual'
        ? `Refreshed ${rows.length} armor items from Bungie.`
        : `Loaded ${rows.length} armor items from Bungie.`;
      setBungieStatus(successMessage, 'ok');
      if(reason === 'auto'){
        bungieAutoLoadedOnce = true;
      }
      if(dimTokens?.accessToken){
        syncDimProfile({ reason, silent: reason !== 'manual' });
      }
      logDebug('loadArmorFromBungie success', { reason, itemCount: rows.length });
      success = true;
    }catch(err){
      console.error(err);
      logDebug('loadArmorFromBungie error', { reason, error: err?.message || err });
      setBungieStatus('Failed to load armor: ' + (err?.message || err), 'error');
    }finally{
      bungieIsFetching = false;
      updateBungieUI();
      logDebug('loadArmorFromBungie finished', { reason, success });
    }
    return success;
  }

  async function initBungieIntegration(){
    logDebug('initBungieIntegration start', {
      hasRefreshToken: Boolean(bungieTokens?.refreshToken)
    });
    updateBungieUI();
    await handleOAuthRedirect();
    if(bungieTokens?.refreshToken){
      const refreshValid = Date.now() < ((bungieTokens.refreshTokenExpires || 0) - 60000);
      if(!refreshValid){
        clearBungieTokens(false);
        setBungieStatus('Your Bungie session expired. Please sign in again.', 'error');
        logDebug('initBungieIntegration expiredRefresh', {});
        return;
      }
      try{
        await ensureAccessToken();
        let membership = getSelectedMembership();
        if(!membership){
          membership = await fetchMemberships();
        }else{
          renderMembershipOptions();
        }
        if(membership && !bungieAutoLoadedOnce){
          const loaded = await loadArmorFromBungie({ reason: 'auto' });
          if(!loaded && !bungieStatusEl?.textContent){
            setBungieStatus(`Signed in as ${membership.label}. Use Refresh armor to try again.`, 'info');
          }
          logDebug('initBungieIntegration autoLoadAttempt', { loaded: Boolean(loaded) });
        }else if(membership && !bungieStatusEl?.textContent){
          setBungieStatus(`Signed in as ${membership.label}.`, 'ok');
        }
      }catch(err){
        console.error(err);
        clearBungieTokens(false);
        setBungieStatus('Your Bungie session expired. Please sign in again.', 'error');
        logDebug('initBungieIntegration refreshError', { error: err?.message || err });
      }
    }else if(!bungieStatusEl?.textContent){
      setBungieStatus('Sign in with Bungie to sync your armor automatically.', 'info');
      logDebug('initBungieIntegration awaitingSignIn', {});
    }
  }
  // ====== Grouping & Sorting ======
  function clusterRows(filtered){
    const byKey = new Map();
    for(const r of filtered){
      const k = r.Rarity==='Exotic' ? `${r.Type}|${normName(r.Name)}` : r.Type; // exotics cluster by name
      if(!byKey.has(k)) byKey.set(k,[]);
      byKey.get(k).push({...r});
    }
    const out=[]; const A='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for(const [key,items] of byKey){
      const assigned = Array(items.length).fill(false);
      const rawGroups = [];
      for(let i=0;i<items.length;i++){
        if(assigned[i]) continue;
        const grp=[i]; assigned[i]=true;
        for(let j=i+1;j<items.length;j++){
          if(assigned[j]) continue;
          if(STATE.sameNameOnly && normName(items[i].Name)!==normName(items[j].Name)) continue;
          if(similarTop3(items[i],items[j],STATE.tol)){ grp.push(j); assigned[j]=true; }
        }
        rawGroups.push(grp);
      }
      // Order groups by best total first, then id to stabilize
      rawGroups.sort((g1,g2)=>{
        const best1 = Math.max(...g1.map(ix=>num(items[ix]["Total (Base)"])));
        const best2 = Math.max(...g2.map(ix=>num(items[ix]["Total (Base)"])));
        if(best1!==best2) return best2-best1;
        return String(items[g1[0]].Id).localeCompare(String(items[g2[0]].Id));
      });
      const isExoticKey = key.includes('|');
      let letterIdx = 0;
      for(const grp of rawGroups){
        const first = items[grp[0]];
        let label = 'X';
        if(grp.length > 1) {
          const letter = A[Math.min(letterIdx, A.length-1)];
          if(isExoticKey) {
            label = `âš ï¸ðŸŸ¡${slotNumber(first.Type)}${letter}`;
          } else {
            label = `âš ï¸${slotNumber(first.Type)}${letter}`;
          }
          letterIdx++;
        }
        for(const gi of grp){
          const it = items[gi];
          const rank = it.Rarity==='Exotic' ? starsExotic(it["Total (Base)"]) : starsLegendary(it["Total (Base)"]); 
          out.push({ 
            ...it, 
            GroupKey:key, 
            Dupe_Group:label, 
            Rank:rank, 
            RankScore:rankScore(rank), 
            Is_Dupe: label!=='X',
            Is_Dupe_Exotic: (it.Rarity==='Exotic' && label!=='X') // <-- Add this flag
          });
        }
      }
    }
    // Final sort: 
out.sort((a, b) => {
  // 1. Slot order
  const sa = slotNumber(a.Type), sb = slotNumber(b.Type);
  if (sa !== sb) return sa - sb;

  // 2. Legendary before Exotic
  const ra = a.Rarity === "Legendary" ? 0 : 1;
  const rb = b.Rarity === "Legendary" ? 0 : 1;
  if (ra !== rb) return ra - rb;

  // 3. Dupe group first within each rarity
  const da = a.Dupe_Group !== "X";
  const db = b.Dupe_Group !== "X";
  if (da !== db) return db - da; // true first

  // 4. For dupe groups: group label, then rank desc, then total desc, then id
  if (da && db) {
    // Group by group key (for exotics, this is name+type)
    if (a.GroupKey !== b.GroupKey) return String(a.GroupKey).localeCompare(String(b.GroupKey));
    if (a.Dupe_Group !== b.Dupe_Group) return String(a.Dupe_Group).localeCompare(String(b.Dupe_Group));
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // 5. For exotics: after dupe groups, show non-grouped exotics of same name below groups
  if (a.Rarity === "Exotic" && b.Rarity === "Exotic") {
    // GroupKey for exotics is type|name
    if (a.GroupKey !== b.GroupKey) return String(a.GroupKey).localeCompare(String(b.GroupKey));
    // Non-grouped exotics of same name (Dupe_Group === "X") come after grouped
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // 6. For legendaries: non-dupes by name, then rank desc, then total desc, then id
  if (a.Rarity === "Legendary" && b.Rarity === "Legendary") {
    const na = String(a.Name).toLowerCase(), nb = String(b.Name).toLowerCase();
    if (na !== nb) return na.localeCompare(nb);
    if (b.RankScore !== a.RankScore) return b.RankScore - a.RankScore;
    const ta = num(a["Total (Base)"]), tb = num(b["Total (Base)"]);
    if (tb !== ta) return tb - ta;
    return String(a.Id).localeCompare(String(b.Id));
  }

  // Fallback: by id
  return String(a.Id).localeCompare(String(b.Id));
});
    return out;
  }

  // ====== Render ======
  function render(){
    updateShadowColor();
    const tolEl=document.getElementById('tol'); if(tolEl) tolEl.value = STATE.tol;
    initFilters();

    const grouped = getFiltered();
    if(debugState.lastRenderCount !== grouped.length){
      debugState.lastRenderCount = grouped.length;
      logDebug('render rows', { visibleRows: grouped.length });
    }
    updateDebugSnapshot();

    // Build group->ids for copy-all
    const groupToIds = new Map();
    for(const it of grouped){ if(it.Dupe_Group==='X') continue; const key=`${it.GroupKey||''}::${it.Dupe_Group}`; if(!groupToIds.has(key)) groupToIds.set(key,[]); groupToIds.get(key).push(normId(it.Id)); }

    const host=document.getElementById('rows');
    const empty=document.getElementById('empty');
    host.innerHTML='';
    if(grouped.length===0){ if(empty) empty.style.display='block'; return; } else { if(empty) empty.style.display='none'; }

    let lastGroup = null;
    let altToggle = false;
    for(const it of grouped){
      // Alternate shade when group changes (by Dupe_Group label)
      if (it.Dupe_Group !== lastGroup) {
        altToggle = !altToggle;
        lastGroup = it.Dupe_Group;
      }
      const row=document.createElement('div');
      row.className = 'row item ' + (altToggle ? 'altA' : 'altB');
      // Tag emoji (DIM tag)
      const cTag = document.createElement('div');
      cTag.className = 'center';
      const tag = (it.Tag || '').toLowerCase();
      cTag.textContent = TAG_EMOJIS[tag] || '';
      cTag.title = TAG_LABELS[tag] || '';
      // Item
      const cItem=document.createElement('div');
      cItem.innerHTML=`<div style="font-weight:700">${it.Name}</div>
        <div class="itemmeta">
          ${(["Warlock Bond","Hunter Cloak","Titan Mark"].includes(it.Type)?"Class Item":it.Type)}
          â€¢ ${it.Equippable}
          â€¢ <img src="${RARITY_ICONS[it.Rarity] || ''}" alt="${it.Rarity}" title="${it.Rarity}" style="height:1em;vertical-align:middle;">
        </div>
        <div class="tiny mono">${normId(it.Id)}</div>`;
      // Tier
      const cTier=document.createElement('div'); 
      cTier.className='tier'; 
      const tVal = Number.isFinite(it.Tier) ? Number(it.Tier) : 0; 
      cTier.textContent = 'â™¦'.repeat(Math.max(1, Math.min(5, tVal)));
      // Stats chips
      const cStats=document.createElement('div'); cStats.className='chips';
      for(const k of STAT_COLS){
        const pill=document.createElement('span'); pill.className=`chipStat ${statColorCls(it[k])}`; pill.title=k.replace(' (Base)','');
        const img=document.createElement('img'); img.className='stat-ico'; img.alt=k; img.src=STAT_ICONS[k]||''; if(img.src) pill.appendChild(img);
        const strong=document.createElement('strong'); strong.className='mono'; strong.textContent=String(it[k]||0); pill.appendChild(strong);
        cStats.appendChild(pill);
      }
      // Total
      const cTotal=document.createElement('div'); cTotal.className='center'; cTotal.style.fontWeight='700'; cTotal.textContent=String(it["Total (Base)"]||0);
      // Group (click to copy all group ids)
      const cGroup=document.createElement('div'); cGroup.className='center';
      if(it.Dupe_Group!=='X'){
        const label = it.Dupe_Group;
        const key=`${it.GroupKey||''}::${it.Dupe_Group}`;
        const list=(groupToIds.get(key)||[]).map(id=>`id:${id}`).join(' or ');
        const span=document.createElement('span'); 
        span.className='badge-warn'; 
        span.title='Click to copy all IDs in this dupe group';

        // PATCH: replace ðŸŸ¡ in label with a rarity <img> for Exotic groups by assembling DOM nodes
        // We keep label text (which might contain âš ï¸ðŸŸ¡1A, etc.) but we render the icon instead of the ðŸŸ¡
        // Detect exotic dupe groups using the label pattern OR the item's rarity
        const exoticGroup = /ðŸŸ¡/.test(label) || it.Rarity === 'Exotic';
        if (exoticGroup && RARITY_ICONS[it.Rarity]) {
          // Split off the visible prefix before slot/letter (remove the emoji if present)
          const textNoYellow = label.replace('ðŸŸ¡','');
          // Optional: if the label still includes the âš ï¸, we keep it in text
          // Prepend the icon after âš ï¸
          const m = textNoYellow.match(/^(âš ï¸)?(.*)$/);
          const prefix = (m && m[1]) ? 'âš ï¸' : '';
          const rest = (m && m[2]) ? m[2] : textNoYellow;
          if (prefix) span.append(prefix);

          const img = new Image();
          img.src = RARITY_ICONS[it.Rarity];
          img.alt = it.Rarity;
          img.title = it.Rarity;
          img.style.height = '1em';
          img.style.verticalAlign = 'middle';
          img.style.marginRight = '4px';
          span.appendChild(img);

          span.append(rest);
        } else {
          // Fallback: plain text
          span.append(label);
        }
        span.addEventListener('click', async ()=>{ const ok=await copyTextSafe(list); if(!ok) alert('Copy failed'); });
        cGroup.appendChild(span);
      } else {
        cGroup.innerHTML = `<span class='badge-ok'>âœ…</span>`;
      }
      // Rank
      const cRank=document.createElement('div'); cRank.className='center'; cRank.textContent=it.Rank||'';
      // Copy single id
      const cCopy=document.createElement('div'); cCopy.className='center';
      const btn=document.createElement('button'); btn.className='btn'; btn.textContent='Copy id';
      btn.addEventListener('click', async ()=>{ const ok=await copyTextSafe(`id:${normId(it.Id)}`); btn.textContent= ok? 'Copied!' : 'Copy id'; setTimeout(()=> btn.textContent='Copy id', 1200); });
      cCopy.appendChild(btn);

      row.append(cTag,cItem,cTier,cStats,cTotal,cGroup,cRank,cCopy);
      host.appendChild(row);
    }
  }

  // ====== Events ======
  initDebugPanel();

  bungieStatusEl = document.getElementById('bungieStatus');
  bungieMembershipSelect = document.getElementById('membershipSelect');
  bungieMembershipWrap = document.getElementById('membershipSelectWrap');
  bungieLoginBtn = document.getElementById('bungieLogin');
  bungieRefreshBtn = document.getElementById('bungieRefresh');
  bungieLogoutBtn = document.getElementById('bungieLogout');

  if(bungieLoginBtn) bungieLoginBtn.addEventListener('click', () => startBungieAuth());
  if(bungieRefreshBtn) bungieRefreshBtn.addEventListener('click', () => loadArmorFromBungie({ reason: 'manual' }));
  if(bungieLogoutBtn) bungieLogoutBtn.addEventListener('click', () => { clearBungieTokens(true); });
  if(bungieMembershipSelect){
    bungieMembershipSelect.addEventListener('change', (event) => {
      const value = event.target.value;
      if(!value) return;
      const [type, id] = value.split(':');
      bungieConfig.membershipType = Number(type);
      bungieConfig.membershipId = id;
      saveBungieConfig();
      dimConfig.lastMembershipId = id;
      saveDimConfig();
      dimProfile = { tags: [], itemHashTags: [], fetchedAt: null, syncToken: null };
      dimSyncToken = null;
      saveDimProfileCache();
      resetBaseTags(STATE.rows);
      applyDimProfileToRows({ render: true });
      updateBungieUI();
      loadArmorFromBungie({ reason: 'auto' });
    });
  }

  const fileInput = document.getElementById('file');
  const restoreBtn = document.getElementById('restoreBtn');
  const clearBtn = document.getElementById('clearBtn');
  const uploadHint = document.getElementById('uploadHint');
  const uploadTrigger = document.getElementById('uploadTrigger');
  const uploadHintDefault = uploadHint?.dataset?.default ?? (uploadHint?.textContent ?? 'Choose DIM Armor.csv');

  const setUploadHint = (text) => { if (uploadHint) uploadHint.textContent = text; };
  const resetUploadHint = () => setUploadHint(uploadHintDefault);

  if (uploadTrigger && fileInput) {
    uploadTrigger.addEventListener('keydown', (evt) => {
      if (evt.key === 'Enter' || evt.key === ' ') {
        evt.preventDefault();
        fileInput.click();
      }
    });
  }

  if (fileInput) {
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (!f) {
        resetUploadHint();
        return;
      }
      const fileName = f.name || 'Selected file';
      setUploadHint(fileName);
      Papa.parse(f, {
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          const data = res.data || [];
          const rows = data.map((r) => {
            const x = { ...r };
            for (const k of [...STAT_COLS, 'Total (Base)', 'Tier']) {
              if (x[k] !== undefined) {
                const n = num(x[k]);
                x[k] = Number.isFinite(n) ? n : 0;
              }
            }
            x.Id = normId(x.Id);
            const possibleHash = r.Hash ?? r.ItemHash ?? r['Item Hash'] ?? r['ItemHash'] ?? r['Hash (Base)'];
            const hashNumber = Number(possibleHash);
            x.ItemHash = Number.isFinite(hashNumber) ? hashNumber : null;
            if(typeof x.Tag !== 'string'){
              x.Tag = x.Tag != null ? String(x.Tag) : '';
            }
            return x;
          });
          resetBaseTags(rows);
          STATE.rows = rows;
          applyDimProfileToRows({ render: false });
          saveRows();
          render();
          fileInput.value = '';
          setUploadHint(`Loaded â€¢ ${fileName}`);
        },
      });
    });
  }

  if (restoreBtn) {
    restoreBtn.addEventListener('click', () => {
      const rows = loadRows();
      if (rows && Array.isArray(rows)) {
        resetBaseTags(rows);
        STATE.rows = rows;
        applyDimProfileToRows({ render: false });
        render();
        resetUploadHint();
      } else {
        alert('No saved CSV found in this browser. Upload a DIM CSV first.');
      }
    });
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      STATE.rows = [];
      rowBaseTags.clear();
      localStorage.removeItem(LS_KEY);
      if (fileInput) fileInput.value = '';
      render();
      resetUploadHint();
    });
  }

  document.getElementById('tol').addEventListener('input', (e) => {
    const v = Number(e.target.value);
    STATE.tol = isFinite(v) ? v : STATE.tol;
    render();
  });

  function updateShadowColor() {
  const root = document.documentElement;
  if (STATE.rarityFilter === "Legendary") {
    root.style.setProperty('--shadow', 'var(--shadow-purple)');
  } else if (STATE.rarityFilter === "Exotic") {
    root.style.setProperty('--shadow', 'var(--shadow-gold)');
  } else {
    root.style.setProperty('--shadow', 'var(--shadow-base)');
  }
}

  // Initial
  initBungieIntegration().catch((err)=>{ console.error('Bungie init error', err); });
  const cached = loadRows();
  if(cached && Array.isArray(cached)){
    resetBaseTags(cached);
    STATE.rows = cached;
    applyDimProfileToRows({ render: false });
  }
  render();
  initDimIntegration();
  updateShadowColor();
</script>
</body>
</html>
